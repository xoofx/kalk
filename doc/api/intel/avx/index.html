<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="lunet 0.5.3.0">
    <title>Intel Avx Intrinsics - kalk</title>
    <link rel="stylesheet" href="/css/site.css">
    <script src="/js/site.js" ></script>
    <script src="/js/site-defer.js" defer></script>
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@xoofx">
    <meta name="twitter:title" content="Intel Avx Intrinsics - kalk">
    <meta name="twitter:description" content="kalk - calculator app">
    <meta name="twitter:image" content="https://kalk.dev/img/twitter-banner.jpg">
    <meta name="twitter:image:alt" content="Intel Avx Intrinsics - kalk">    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-Z558CWX6J6" async></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-Z558CWX6J6');</script>
  </head>
  <body>

    <div id="kalk" class="container">
      <nav class="navbar navbar-expand-md navbar-light sticky-top">
        <a class="kalk-logo navbar-brand" href="/"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div id="navbarSupportedContent" class="collapse navbar-collapse justify-content-between">
<ol id='nav-id-home-0' class='navbar-nav nav-level0  '>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/' class='nav-link  '>Home</a></span>  </li>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/doc/' class='nav-link  '>Documentation</a></span>  </li>
</ol>
          <ol class="navbar-nav flex-grow-1" style="padding-right: 0.5rem;">
            <li class="nav-item w-100">
                <div class="kalk-search">
                  <label class="search-icon"><i class="fa fa-search"></i></label>
                  <select id="search-box"></select>
                </div>
            </li>
          </ol>
<ol id='nav-id-home2-0' class='navbar-nav nav-level0  flex-shrink-0'>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/download/' class='nav-link  btn btn-success'><i class="fa fa-download"></i> Download</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/sponsors/xoofx' class='nav-link  btn btn-outline-secondary'><i class="fa fa-heart-o"></i> Sponsor</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/xoofx/kalk/' class='nav-link  btn btn-info'><i class="fa fa-github"></i> GitHub</a></span>  </li>
</ol>
        </div>
      </nav>
      <div class="kalk-doc">
        <section>

<div class="container">
  <div class="row">
      <div class="col-sm-3 align-self-start sticky-top menu-sidebar">
        <ol id='menu-id-doc-0' class='menu menu-level0 collapse  show '>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/' class='menu-link  '>Introduction</a></span>  </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/user/' class='menu-link  '>User Guide</a><a href='#menu-id-doc-2' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-2' class='menu-link-show collapsed'></a></span>  <ol id='menu-id-doc-2' class='menu menu-level1 collapse  '>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/user/syntax/' class='menu-link  '>Language Syntax</a></span>    </li>
          </ol>
          </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/api/' class='menu-link  '>API Reference</a><a href='#menu-id-doc-4' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-4' class='menu-link-show'></a></span>  <ol id='menu-id-doc-4' class='menu menu-level1 collapse  show '>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/general/' class='menu-link  '>General Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/math/' class='menu-link  '>Math Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/memory/' class='menu-link  '>Memory Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/misc/' class='menu-link  '>Misc Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/vector/' class='menu-link  '>Vector Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/types/' class='menu-link  '>Types Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/all/' class='menu-link  '>All Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/csv/' class='menu-link  '>Csv Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/currencies/' class='menu-link  '>Currencies Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/files/' class='menu-link  '>Files Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/standardunits/' class='menu-link  '>StandardUnits Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/strings/' class='menu-link  '>Strings Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/web/' class='menu-link  '>Web Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/intel/' class='menu-link  '>Intel Hardware Intrinsics</a><a href='#menu-id-doc-18' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-18' class='menu-link-show'></a></span>    <ol id='menu-id-doc-18' class='menu menu-level2 collapse  show '>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/aes/' class='menu-link  '>Intel Aes Intrinsics</a></span>      </li>
              <li class='menu-item  active'>
                <span class='menu-item-row'><a href='/doc/api/intel/avx/' class='menu-link  '>Intel Avx Intrinsics</a></span><nav class="js-toc toc"></nav>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/avx2/' class='menu-link  '>Intel Avx2 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi1/' class='menu-link  '>Intel Bmi1 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi1x64/' class='menu-link  '>Intel Bmi1X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi2/' class='menu-link  '>Intel Bmi2 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi2x64/' class='menu-link  '>Intel Bmi2X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse/' class='menu-link  '>Intel Sse Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/ssex64/' class='menu-link  '>Intel SseX64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse2/' class='menu-link  '>Intel Sse2 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse2x64/' class='menu-link  '>Intel Sse2X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse3/' class='menu-link  '>Intel Sse3 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/ssse3/' class='menu-link  '>Intel Ssse3 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse41/' class='menu-link  '>Intel Sse41 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse41x64/' class='menu-link  '>Intel Sse41X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse42/' class='menu-link  '>Intel Sse42 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse42x64/' class='menu-link  '>Intel Sse42X64 Intrinsics</a></span>      </li>
            </ol>
            </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/arm/' class='menu-link  '>Arm Hardware Intrinsics</a><a href='#menu-id-doc-36' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-36' class='menu-link-show collapsed'></a></span>    <ol id='menu-id-doc-36' class='menu menu-level2 collapse  '>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/advsimd/' class='menu-link  '>Arm AdvSimd Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/advsimdarm64/' class='menu-link  '>Arm AdvSimdArm64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/aes/' class='menu-link  '>Arm Aes Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/crc32/' class='menu-link  '>Arm Crc32 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/crc32arm64/' class='menu-link  '>Arm Crc32Arm64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/sha1/' class='menu-link  '>Arm Sha1 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/sha256/' class='menu-link  '>Arm Sha256 Intrinsics</a></span>      </li>
            </ol>
            </li>
          </ol>
          </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/advanced/' class='menu-link  '>Advanced Topics</a></span>  </li>
        </ol>

      </div>
      <div class="col-sm-9 js-toc-content">
        <ol class='breadcrumb'>
          <li class='breadcrumb-item '>
            <a href='/' class='breadcrumb-link  '>Home</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/' class='breadcrumb-link  '>Documentation</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/api/' class='breadcrumb-link  '>API Reference</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/api/intel/' class='breadcrumb-link  '>Intel Hardware Intrinsics</a>  </li>
          <li class='breadcrumb-item  active'>
            Intel Avx Intrinsics  </li>
        </ol>

        <p id="lunet-results"></p>
        <h1>Intel Avx Intrinsics</h1>
<p>In order to use the functions provided by this module, you need to import this module:</p>
<pre><code class="language-kalk">&gt;&gt;&gt; import HardwareIntrinsics
</code></pre>
<div class='lunet-alert-note' role='alert'><div class='lunet-alert-note-heading'><span class='lunet-alert-note-icon'></span><span class='lunet-alert-note-heading-text'></span></div><div class='lunet-alert-note-content'>
<p>These intrinsic functions are only available if your CPU supports <code>Avx</code> features.</p>
</div></div>
<h2 id="mm256_add_pd">mm256_add_pd</h2>
<p><code>mm256_add_pd</code></p>
<p>Add packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_add_pd (__m256d a, __m256d b)
VADDPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_add_ps">mm256_add_ps</h2>
<p><code>mm256_add_ps</code></p>
<p>Add packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_add_ps (__m256 a, __m256 b)
VADDPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_addsub_pd">mm256_addsub_pd</h2>
<p><code>mm256_addsub_pd</code></p>
<p>Alternatively add and subtract packed double-precision (64-bit) floating-point elements in &quot;a&quot; to/from packed elements in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_addsub_pd (__m256d a, __m256d b)
VADDSUBPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_addsub_ps">mm256_addsub_ps</h2>
<p><code>mm256_addsub_ps</code></p>
<p>Alternatively add and subtract packed single-precision (32-bit) floating-point elements in &quot;a&quot; to/from packed elements in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_addsub_ps (__m256 a, __m256 b)
VADDSUBPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_and_pd">mm256_and_pd</h2>
<p><code>mm256_and_pd</code></p>
<p>Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_and_pd (__m256d a, __m256d b)
VANDPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_and_ps">mm256_and_ps</h2>
<p><code>mm256_and_ps</code></p>
<p>Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_and_ps (__m256 a, __m256 b)
VANDPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_andnot_pd">mm256_andnot_pd</h2>
<p><code>mm256_andnot_pd</code></p>
<p>Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and then AND with &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_andnot_pd (__m256d a, __m256d b)
VANDNPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_andnot_ps">mm256_andnot_ps</h2>
<p><code>mm256_andnot_ps</code></p>
<p>Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in &quot;a&quot; and then AND with &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_andnot_ps (__m256 a, __m256 b)
VANDNPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_blend_pd">mm256_blend_pd</h2>
<p><code>mm256_blend_pd</code></p>
<p>Blend packed double-precision (64-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using control mask &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8)
VBLENDPD ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_blend_ps">mm256_blend_ps</h2>
<p><code>mm256_blend_ps</code></p>
<p>Blend packed single-precision (32-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using control mask &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8)
VBLENDPS ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_blendv_pd">mm256_blendv_pd</h2>
<p><code>mm256_blendv_pd</code></p>
<p>Blend packed double-precision (64-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using &quot;mask&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
VBLENDVPD ymm, ymm, ymm/m256, ymm</p>
<h2 id="mm256_blendv_ps">mm256_blendv_ps</h2>
<p><code>mm256_blendv_ps</code></p>
<p>Blend packed single-precision (32-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using &quot;mask&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask)
VBLENDVPS ymm, ymm, ymm/m256, ymm</p>
<h2 id="mm256_broadcast_pd">mm256_broadcast_pd</h2>
<p><code>mm256_broadcast_pd</code></p>
<p>Broadcast 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of &quot;dst&quot;.</p>
<p>__m256d _mm256_broadcast_pd (__m128d const * mem_addr)
VBROADCASTF128, ymm, m128</p>
<h2 id="mm256_broadcast_ps">mm256_broadcast_ps</h2>
<p><code>mm256_broadcast_ps</code></p>
<p>Broadcast 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of &quot;dst&quot;.</p>
<p>__m256 _mm256_broadcast_ps (__m128 const * mem_addr)
VBROADCASTF128, ymm, m128</p>
<h2 id="mm256_broadcast_sd">mm256_broadcast_sd</h2>
<p><code>mm256_broadcast_sd</code></p>
<p>Broadcast a double-precision (64-bit) floating-point element from memory to all elements of &quot;dst&quot;.</p>
<p>__m256d _mm256_broadcast_sd (double const * mem_addr)
VBROADCASTSD ymm, m64</p>
<h2 id="mm256_broadcast_ss">mm256_broadcast_ss</h2>
<p><code>mm256_broadcast_ss</code></p>
<p>Broadcast a single-precision (32-bit) floating-point element from memory to all elements of &quot;dst&quot;.</p>
<p>__m256 _mm256_broadcast_ss (float const * mem_addr)
VBROADCASTSS ymm, m32</p>
<h2 id="mm256_ceil_pd">mm256_ceil_pd</h2>
<p><code>mm256_ceil_pd</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; up to an integer value, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_ceil_pd (__m256d a)
VROUNDPD ymm, ymm/m256, imm8(10)</p>
<h2 id="mm256_ceil_ps">mm256_ceil_ps</h2>
<p><code>mm256_ceil_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; up to an integer value, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_ceil_ps (__m256 a)
VROUNDPS ymm, ymm/m256, imm8(10)</p>
<h2 id="mm256_cmp_pd">mm256_cmp_pd</h2>
<p><code>mm256_cmp_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
VCMPPD ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_cmp_ps">mm256_cmp_ps</h2>
<p><code>mm256_cmp_ps</code></p>
<p>Compare packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8)
VCMPPS ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_cmpeq_pd">mm256_cmpeq_pd</h2>
<p><code>mm256_cmpeq_pd</code></p>
<p>__m256d _mm256_cmpeq_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(0)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpeq_ps">mm256_cmpeq_ps</h2>
<p><code>mm256_cmpeq_ps</code></p>
<p>__m256 _mm256_cmpeq_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(0)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpge_pd">mm256_cmpge_pd</h2>
<p><code>mm256_cmpge_pd</code></p>
<p>__m256d _mm256_cmpge_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(13)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpge_ps">mm256_cmpge_ps</h2>
<p><code>mm256_cmpge_ps</code></p>
<p>__m256 _mm256_cmpge_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(13)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpgt_pd">mm256_cmpgt_pd</h2>
<p><code>mm256_cmpgt_pd</code></p>
<p>__m256d _mm256_cmpgt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(14)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpgt_ps">mm256_cmpgt_ps</h2>
<p><code>mm256_cmpgt_ps</code></p>
<p>__m256 _mm256_cmpgt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(14)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmple_pd">mm256_cmple_pd</h2>
<p><code>mm256_cmple_pd</code></p>
<p>__m256d _mm256_cmple_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(2)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmple_ps">mm256_cmple_ps</h2>
<p><code>mm256_cmple_ps</code></p>
<p>__m256 _mm256_cmple_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(2)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmplt_pd">mm256_cmplt_pd</h2>
<p><code>mm256_cmplt_pd</code></p>
<p>__m256d _mm256_cmplt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(1)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmplt_ps">mm256_cmplt_ps</h2>
<p><code>mm256_cmplt_ps</code></p>
<p>__m256 _mm256_cmplt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(1)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpneq_pd">mm256_cmpneq_pd</h2>
<p><code>mm256_cmpneq_pd</code></p>
<p>__m256d _mm256_cmpneq_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(4)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpneq_ps">mm256_cmpneq_ps</h2>
<p><code>mm256_cmpneq_ps</code></p>
<p>__m256 _mm256_cmpneq_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(4)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnge_pd">mm256_cmpnge_pd</h2>
<p><code>mm256_cmpnge_pd</code></p>
<p>__m256d _mm256_cmpnge_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(9)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnge_ps">mm256_cmpnge_ps</h2>
<p><code>mm256_cmpnge_ps</code></p>
<p>__m256 _mm256_cmpnge_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(9)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpngt_pd">mm256_cmpngt_pd</h2>
<p><code>mm256_cmpngt_pd</code></p>
<p>__m256d _mm256_cmpngt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(10)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpngt_ps">mm256_cmpngt_ps</h2>
<p><code>mm256_cmpngt_ps</code></p>
<p>__m256 _mm256_cmpngt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(10)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnle_pd">mm256_cmpnle_pd</h2>
<p><code>mm256_cmpnle_pd</code></p>
<p>__m256d _mm256_cmpnle_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(6)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnle_ps">mm256_cmpnle_ps</h2>
<p><code>mm256_cmpnle_ps</code></p>
<p>__m256 _mm256_cmpnle_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(6)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnlt_pd">mm256_cmpnlt_pd</h2>
<p><code>mm256_cmpnlt_pd</code></p>
<p>__m256d _mm256_cmpnlt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(5)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpnlt_ps">mm256_cmpnlt_ps</h2>
<p><code>mm256_cmpnlt_ps</code></p>
<p>__m256 _mm256_cmpnlt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(5)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpord_pd">mm256_cmpord_pd</h2>
<p><code>mm256_cmpord_pd</code></p>
<p>__m256d _mm256_cmpord_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(7)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpord_ps">mm256_cmpord_ps</h2>
<p><code>mm256_cmpord_ps</code></p>
<p>__m256 _mm256_cmpord_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(7)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpunord_pd">mm256_cmpunord_pd</h2>
<p><code>mm256_cmpunord_pd</code></p>
<p>__m256d _mm256_cmpunord_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(3)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cmpunord_ps">mm256_cmpunord_ps</h2>
<p><code>mm256_cmpunord_ps</code></p>
<p>__m256 _mm256_cmpunord_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(3)
The above native signature does not exist. We provide this additional overload for completeness.</p>
<h2 id="mm256_cvtepi32_pd">mm256_cvtepi32_pd</h2>
<p><code>mm256_cvtepi32_pd</code></p>
<p>Convert packed 32-bit integers in &quot;a&quot; to packed double-precision (64-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_cvtepi32_pd (__m128i a)
VCVTDQ2PD ymm, xmm/m128</p>
<h2 id="mm256_cvtepi32_ps">mm256_cvtepi32_ps</h2>
<p><code>mm256_cvtepi32_ps</code></p>
<p>Convert packed 32-bit integers in &quot;a&quot; to packed single-precision (32-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_cvtepi32_ps (__m256i a)
VCVTDQ2PS ymm, ymm/m256</p>
<h2 id="mm256_cvtpd_epi32">mm256_cvtpd_epi32</h2>
<p><code>mm256_cvtpd_epi32</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm256_cvtpd_epi32 (__m256d a)
VCVTPD2DQ xmm, ymm/m256</p>
<h2 id="mm256_cvtpd_ps">mm256_cvtpd_ps</h2>
<p><code>mm256_cvtpd_ps</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed single-precision (32-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm256_cvtpd_ps (__m256d a)
VCVTPD2PS xmm, ymm/m256</p>
<h2 id="mm256_cvtps_epi32">mm256_cvtps_epi32</h2>
<p><code>mm256_cvtps_epi32</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m256i _mm256_cvtps_epi32 (__m256 a)
VCVTPS2DQ ymm, ymm/m256</p>
<h2 id="mm256_cvtps_pd">mm256_cvtps_pd</h2>
<p><code>mm256_cvtps_pd</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed double-precision (64-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_cvtps_pd (__m128 a)
VCVTPS2PD ymm, xmm/m128</p>
<h2 id="mm256_cvttpd_epi32">mm256_cvttpd_epi32</h2>
<p><code>mm256_cvttpd_epi32</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers with truncation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm256_cvttpd_epi32 (__m256d a)
VCVTTPD2DQ xmm, ymm/m256</p>
<h2 id="mm256_cvttps_epi32">mm256_cvttps_epi32</h2>
<p><code>mm256_cvttps_epi32</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers with truncation, and store the results in &quot;dst&quot;.</p>
<p>__m256i _mm256_cvttps_epi32 (__m256 a)
VCVTTPS2DQ ymm, ymm/m256</p>
<h2 id="mm256_div_pd">mm256_div_pd</h2>
<p><code>mm256_div_pd</code></p>
<p>Divide packed double-precision (64-bit) floating-point elements in &quot;a&quot; by packed elements in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_div_pd (__m256d a, __m256d b)
VDIVPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_div_ps">mm256_div_ps</h2>
<p><code>mm256_div_ps</code></p>
<p>Divide packed single-precision (32-bit) floating-point elements in &quot;a&quot; by packed elements in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_div_ps (__m256 a, __m256 b)
VDIVPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_dp_ps">mm256_dp_ps</h2>
<p><code>mm256_dp_ps</code></p>
<p>Conditionally multiply the packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; using the high 4 bits in &quot;imm8&quot;, sum the four products, and conditionally store the sum in &quot;dst&quot; using the low 4 bits of &quot;imm8&quot;.</p>
<p>__m256 _mm256_dp_ps (__m256 a, __m256 b, const int imm8)
VDPPS ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_extractf128_pd">mm256_extractf128_pd</h2>
<p><code>mm256_extractf128_pd</code></p>
<p>Extract 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128d _mm256_extractf128_pd (__m256d a, const int imm8)
VEXTRACTF128 xmm/m128, ymm, imm8</p>
<h2 id="mm256_extractf128_ps">mm256_extractf128_ps</h2>
<p><code>mm256_extractf128_ps</code></p>
<p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128 _mm256_extractf128_ps (__m256 a, const int imm8)
VEXTRACTF128 xmm/m128, ymm, imm8</p>
<h2 id="mm256_extractf128_si256">mm256_extractf128_si256</h2>
<p><code>mm256_extractf128_si256</code></p>
<p>Extract 128 bits (composed of integer data) from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
VEXTRACTF128 xmm/m128, ymm, imm8</p>
<h2 id="mm256_floor_pd">mm256_floor_pd</h2>
<p><code>mm256_floor_pd</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; down to an integer value, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_floor_pd (__m256d a)
VROUNDPS ymm, ymm/m256, imm8(9)</p>
<h2 id="mm256_floor_ps">mm256_floor_ps</h2>
<p><code>mm256_floor_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; down to an integer value, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_floor_ps (__m256 a)
VROUNDPS ymm, ymm/m256, imm8(9)</p>
<h2 id="mm256_hadd_pd">mm256_hadd_pd</h2>
<p><code>mm256_hadd_pd</code></p>
<p>Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and pack the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_hadd_pd (__m256d a, __m256d b)
VHADDPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_hadd_ps">mm256_hadd_ps</h2>
<p><code>mm256_hadd_ps</code></p>
<p>Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and pack the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_hadd_ps (__m256 a, __m256 b)
VHADDPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_hsub_pd">mm256_hsub_pd</h2>
<p><code>mm256_hsub_pd</code></p>
<p>Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and pack the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_hsub_pd (__m256d a, __m256d b)
VHSUBPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_hsub_ps">mm256_hsub_ps</h2>
<p><code>mm256_hsub_ps</code></p>
<p>Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and pack the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_hsub_ps (__m256 a, __m256 b)
VHSUBPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_insertf128_pd">mm256_insertf128_pd</h2>
<p><code>mm256_insertf128_pd</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, then insert 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from &quot;b&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m256d _mm256_insertf128_pd (__m256d a, __m128d b, int imm8)
VINSERTF128 ymm, ymm, xmm/m128, imm8</p>
<h2 id="mm256_insertf128_ps">mm256_insertf128_ps</h2>
<p><code>mm256_insertf128_ps</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from &quot;b&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m256 _mm256_insertf128_ps (__m256 a, __m128 b, int imm8)
VINSERTF128 ymm, ymm, xmm/m128, imm8</p>
<h2 id="mm256_insertf128_si256">mm256_insertf128_si256</h2>
<p><code>mm256_insertf128_si256</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, then insert 128 bits from &quot;b&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
VINSERTF128 ymm, ymm, xmm/m128, imm8</p>
<h2 id="mm256_lddqu_si256">mm256_lddqu_si256</h2>
<p><code>mm256_lddqu_si256</code></p>
<p>Load 256-bits of integer data from unaligned memory into &quot;dst&quot;. This intrinsic may perform better than &quot;_mm256_loadu_si256&quot; when the data crosses a cache line boundary.</p>
<p>__m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
VLDDQU ymm, m256</p>
<h2 id="mm256_load_pd">mm256_load_pd</h2>
<p><code>mm256_load_pd</code></p>
<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>__m256d _mm256_load_pd (double const * mem_addr)
VMOVAPD ymm, ymm/m256</p>
<h2 id="mm256_load_ps">mm256_load_ps</h2>
<p><code>mm256_load_ps</code></p>
<p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>__m256 _mm256_load_ps (float const * mem_addr)
VMOVAPS ymm, ymm/m256</p>
<h2 id="mm256_load_si256">mm256_load_si256</h2>
<p><code>mm256_load_si256</code></p>
<p>Load 256-bits of integer data from memory into &quot;dst&quot;.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>__m256i _mm256_load_si256 (__m256i const * mem_addr)
VMOVDQA ymm, m256</p>
<h2 id="mm256_loadu_pd">mm256_loadu_pd</h2>
<p><code>mm256_loadu_pd</code></p>
<p>Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m256d _mm256_loadu_pd (double const * mem_addr)
VMOVUPD ymm, ymm/m256</p>
<h2 id="mm256_loadu_ps">mm256_loadu_ps</h2>
<p><code>mm256_loadu_ps</code></p>
<p>Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m256 _mm256_loadu_ps (float const * mem_addr)
VMOVUPS ymm, ymm/m256</p>
<h2 id="mm256_loadu_si256">mm256_loadu_si256</h2>
<p><code>mm256_loadu_si256</code></p>
<p>Load 256-bits of integer data from memory into &quot;dst&quot;.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m256i _mm256_loadu_si256 (__m256i const * mem_addr)
VMOVDQU ymm, m256</p>
<h2 id="mm256_maskload_pd">mm256_maskload_pd</h2>
<p><code>mm256_maskload_pd</code></p>
<p>Load packed double-precision (64-bit) floating-point elements from memory into &quot;dst&quot; using &quot;mask&quot; (elements are zeroed out when the high bit of the corresponding element is not set).</p>
<p>__m256d _mm256_maskload_pd (double const * mem_addr, __m256i mask)
VMASKMOVPD ymm, ymm, m256</p>
<h2 id="mm256_maskload_ps">mm256_maskload_ps</h2>
<p><code>mm256_maskload_ps</code></p>
<p>Load packed single-precision (32-bit) floating-point elements from memory into &quot;dst&quot; using &quot;mask&quot; (elements are zeroed out when the high bit of the corresponding element is not set).</p>
<p>__m256 _mm256_maskload_ps (float const * mem_addr, __m256i mask)
VMASKMOVPS ymm, ymm, m256</p>
<h2 id="mm256_maskstore_pd">mm256_maskstore_pd</h2>
<p><code>mm256_maskstore_pd</code></p>
<p>Store packed double-precision (64-bit) floating-point elements from &quot;a&quot; into memory using &quot;mask&quot;.</p>
<p>void _mm256_maskstore_pd (double * mem_addr, __m256i mask, __m256d a)
VMASKMOVPD m256, ymm, ymm</p>
<h2 id="mm256_maskstore_ps">mm256_maskstore_ps</h2>
<p><code>mm256_maskstore_ps</code></p>
<p>Store packed single-precision (32-bit) floating-point elements from &quot;a&quot; into memory using &quot;mask&quot;.</p>
<p>void _mm256_maskstore_ps (float * mem_addr, __m256i mask, __m256 a)
VMASKMOVPS m256, ymm, ymm</p>
<h2 id="mm256_max_pd">mm256_max_pd</h2>
<p><code>mm256_max_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m256d _mm256_max_pd (__m256d a, __m256d b)
VMAXPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_max_ps">mm256_max_ps</h2>
<p><code>mm256_max_ps</code></p>
<p>Compare packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m256 _mm256_max_ps (__m256 a, __m256 b)
VMAXPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_min_pd">mm256_min_pd</h2>
<p><code>mm256_min_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m256d _mm256_min_pd (__m256d a, __m256d b)
VMINPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_min_ps">mm256_min_ps</h2>
<p><code>mm256_min_ps</code></p>
<p>Compare packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m256 _mm256_min_ps (__m256 a, __m256 b)
VMINPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_movedup_pd">mm256_movedup_pd</h2>
<p><code>mm256_movedup_pd</code></p>
<p>Duplicate even-indexed double-precision (64-bit) floating-point elements from &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_movedup_pd (__m256d a)
VMOVDDUP ymm, ymm/m256</p>
<h2 id="mm256_movehdup_ps">mm256_movehdup_ps</h2>
<p><code>mm256_movehdup_ps</code></p>
<p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_movehdup_ps (__m256 a)
VMOVSHDUP ymm, ymm/m256</p>
<h2 id="mm256_moveldup_ps">mm256_moveldup_ps</h2>
<p><code>mm256_moveldup_ps</code></p>
<p>Duplicate even-indexed single-precision (32-bit) floating-point elements from &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_moveldup_ps (__m256 a)
VMOVSLDUP ymm, ymm/m256</p>
<h2 id="mm256_movemask_pd">mm256_movemask_pd</h2>
<p><code>mm256_movemask_pd</code></p>
<p>Set each bit of mask &quot;dst&quot; based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in &quot;a&quot;.</p>
<p>int _mm256_movemask_pd (__m256d a)
VMOVMSKPD reg, ymm</p>
<h2 id="mm256_movemask_ps">mm256_movemask_ps</h2>
<p><code>mm256_movemask_ps</code></p>
<p>Set each bit of mask &quot;dst&quot; based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in &quot;a&quot;.</p>
<p>int _mm256_movemask_ps (__m256 a)
VMOVMSKPS reg, ymm</p>
<h2 id="mm256_mul_pd">mm256_mul_pd</h2>
<p><code>mm256_mul_pd</code></p>
<p>Multiply packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_mul_pd (__m256d a, __m256d b)
VMULPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_mul_ps">mm256_mul_ps</h2>
<p><code>mm256_mul_ps</code></p>
<p>Multiply packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_mul_ps (__m256 a, __m256 b)
VMULPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_or_pd">mm256_or_pd</h2>
<p><code>mm256_or_pd</code></p>
<p>Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_or_pd (__m256d a, __m256d b)
VORPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_or_ps">mm256_or_ps</h2>
<p><code>mm256_or_ps</code></p>
<p>Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_or_ps (__m256 a, __m256 b)
VORPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_permute2f128_pd">mm256_permute2f128_pd</h2>
<p><code>mm256_permute2f128_pd</code></p>
<p>Shuffle 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) selected by &quot;imm8&quot; from &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_permute2f128_pd (__m256d a, __m256d b, int imm8)
VPERM2F128 ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_permute2f128_ps">mm256_permute2f128_ps</h2>
<p><code>mm256_permute2f128_ps</code></p>
<p>Shuffle 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) selected by &quot;imm8&quot; from &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_permute2f128_ps (__m256 a, __m256 b, int imm8)
VPERM2F128 ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_permute2f128_si256">mm256_permute2f128_si256</h2>
<p><code>mm256_permute2f128_si256</code></p>
<p>Shuffle 128-bits (composed of integer data) selected by &quot;imm8&quot; from &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
VPERM2F128 ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_permute_pd">mm256_permute_pd</h2>
<p><code>mm256_permute_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements in &quot;a&quot; within 128-bit lanes using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_permute_pd (__m256d a, int imm8)
VPERMILPD ymm, ymm, imm8</p>
<h2 id="mm256_permute_ps">mm256_permute_ps</h2>
<p><code>mm256_permute_ps</code></p>
<p>Shuffle single-precision (32-bit) floating-point elements in &quot;a&quot; within 128-bit lanes using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_permute_ps (__m256 a, int imm8)
VPERMILPS ymm, ymm, imm8</p>
<h2 id="mm256_permutevar_pd">mm256_permutevar_pd</h2>
<p><code>mm256_permutevar_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements in &quot;a&quot; within 128-bit lanes using the control in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_permutevar_pd (__m256d a, __m256i b)
VPERMILPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_permutevar_ps">mm256_permutevar_ps</h2>
<p><code>mm256_permutevar_ps</code></p>
<p>Shuffle single-precision (32-bit) floating-point elements in &quot;a&quot; within 128-bit lanes using the control in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_permutevar_ps (__m256 a, __m256i b)
VPERMILPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_rcp_ps">mm256_rcp_ps</h2>
<p><code>mm256_rcp_ps</code></p>
<p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;. The maximum relative error for this approximation is less than 1.5*2^-12.</p>
<p>__m256 _mm256_rcp_ps (__m256 a)
VRCPPS ymm, ymm/m256</p>
<h2 id="mm256_round_pd1">mm256_round_pd1</h2>
<p><code>mm256_round_pd1</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_round_pd (__m256d a, _MM_FROUND_CUR_DIRECTION)
VROUNDPD ymm, ymm/m256, imm8(4)</p>
<h2 id="mm256_round_pd1_to_nearest_integer">mm256_round_pd1_to_nearest_integer</h2>
<p><code>mm256_round_pd1_to_nearest_integer</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
VROUNDPD ymm, ymm/m256, imm8(8)</p>
<h2 id="mm256_round_pd1_to_negative_infinity">mm256_round_pd1_to_negative_infinity</h2>
<p><code>mm256_round_pd1_to_negative_infinity</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
VROUNDPD ymm, ymm/m256, imm8(9)</p>
<h2 id="mm256_round_pd1_to_positive_infinity">mm256_round_pd1_to_positive_infinity</h2>
<p><code>mm256_round_pd1_to_positive_infinity</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
VROUNDPD ymm, ymm/m256, imm8(10)</p>
<h2 id="mm256_round_pd1_to_zero">mm256_round_pd1_to_zero</h2>
<p><code>mm256_round_pd1_to_zero</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
VROUNDPD ymm, ymm/m256, imm8(11)</p>
<h2 id="mm256_round_ps">mm256_round_ps</h2>
<p><code>mm256_round_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_round_ps (__m256 a, _MM_FROUND_CUR_DIRECTION)
VROUNDPS ymm, ymm/m256, imm8(4)</p>
<h2 id="mm256_round_ps_to_nearest_integer">mm256_round_ps_to_nearest_integer</h2>
<p><code>mm256_round_ps_to_nearest_integer</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
VROUNDPS ymm, ymm/m256, imm8(8)</p>
<h2 id="mm256_round_ps_to_negative_infinity">mm256_round_ps_to_negative_infinity</h2>
<p><code>mm256_round_ps_to_negative_infinity</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
VROUNDPS ymm, ymm/m256, imm8(9)</p>
<h2 id="mm256_round_ps_to_positive_infinity">mm256_round_ps_to_positive_infinity</h2>
<p><code>mm256_round_ps_to_positive_infinity</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
VROUNDPS ymm, ymm/m256, imm8(10)</p>
<h2 id="mm256_round_ps_to_zero">mm256_round_ps_to_zero</h2>
<p><code>mm256_round_ps_to_zero</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
VROUNDPS ymm, ymm/m256, imm8(11)</p>
<h2 id="mm256_rsqrt_ps">mm256_rsqrt_ps</h2>
<p><code>mm256_rsqrt_ps</code></p>
<p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;. The maximum relative error for this approximation is less than 1.5*2^-12.</p>
<p>__m256 _mm256_rsqrt_ps (__m256 a)
VRSQRTPS ymm, ymm/m256</p>
<h2 id="mm256_shuffle_pd">mm256_shuffle_pd</h2>
<p><code>mm256_shuffle_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int imm8)
VSHUFPD ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_shuffle_ps">mm256_shuffle_ps</h2>
<p><code>mm256_shuffle_ps</code></p>
<p>Shuffle single-precision (32-bit) floating-point elements in &quot;a&quot; within 128-bit lanes using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_shuffle_ps (__m256 a, __m256 b, const int imm8)
VSHUFPS ymm, ymm, ymm/m256, imm8</p>
<h2 id="mm256_sqrt_pd">mm256_sqrt_pd</h2>
<p><code>mm256_sqrt_pd</code></p>
<p>Compute the square root of packed double-precision (64-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_sqrt_pd (__m256d a)
VSQRTPD ymm, ymm/m256</p>
<h2 id="mm256_sqrt_ps">mm256_sqrt_ps</h2>
<p><code>mm256_sqrt_ps</code></p>
<p>Compute the square root of packed single-precision (32-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_sqrt_ps (__m256 a)
VSQRTPS ymm, ymm/m256</p>
<h2 id="mm256_store_pd">mm256_store_pd</h2>
<p><code>mm256_store_pd</code></p>
<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_store_pd (double * mem_addr, __m256d a)
VMOVAPD m256, ymm</p>
<h2 id="mm256_store_ps">mm256_store_ps</h2>
<p><code>mm256_store_ps</code></p>
<p>Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_store_ps (float * mem_addr, __m256 a)
VMOVAPS m256, ymm</p>
<h2 id="mm256_store_si256">mm256_store_si256</h2>
<p><code>mm256_store_si256</code></p>
<p>Store 256-bits of integer data from &quot;a&quot; into memory.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
MOVDQA m256, ymm</p>
<h2 id="mm256_storeu_pd">mm256_storeu_pd</h2>
<p><code>mm256_storeu_pd</code></p>
<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm256_storeu_pd (double * mem_addr, __m256d a)
MOVUPD m256, ymm</p>
<h2 id="mm256_storeu_ps">mm256_storeu_ps</h2>
<p><code>mm256_storeu_ps</code></p>
<p>Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm256_storeu_ps (float * mem_addr, __m256 a)
MOVUPS m256, ymm</p>
<h2 id="mm256_storeu_si256">mm256_storeu_si256</h2>
<p><code>mm256_storeu_si256</code></p>
<p>Store 256-bits of integer data from &quot;a&quot; into memory.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
MOVDQU m256, ymm</p>
<h2 id="mm256_stream_pd">mm256_stream_pd</h2>
<p><code>mm256_stream_pd</code></p>
<p>Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_stream_pd (double * mem_addr, __m256d a)
MOVNTPD m256, ymm</p>
<h2 id="mm256_stream_ps">mm256_stream_ps</h2>
<p><code>mm256_stream_ps</code></p>
<p>Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from &quot;a&quot; into memory using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_stream_ps (float * mem_addr, __m256 a)
MOVNTPS m256, ymm</p>
<h2 id="mm256_stream_si256">mm256_stream_si256</h2>
<p><code>mm256_stream_si256</code></p>
<p>Store 256-bits of integer data from &quot;a&quot; into memory using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
VMOVNTDQ m256, ymm</p>
<h2 id="mm256_sub_pd">mm256_sub_pd</h2>
<p><code>mm256_sub_pd</code></p>
<p>Subtract packed double-precision (64-bit) floating-point elements in &quot;b&quot; from packed double-precision (64-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_sub_pd (__m256d a, __m256d b)
VSUBPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_sub_ps">mm256_sub_ps</h2>
<p><code>mm256_sub_ps</code></p>
<p>Subtract packed single-precision (32-bit) floating-point elements in &quot;b&quot; from packed single-precision (32-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_sub_ps (__m256 a, __m256 b)
VSUBPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_testc_pd">mm256_testc_pd</h2>
<p><code>mm256_testc_pd</code></p>
<p>Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm256_testc_pd (__m256d a, __m256d b)
VTESTPS ymm, ymm/m256</p>
<h2 id="mm256_testc_ps">mm256_testc_ps</h2>
<p><code>mm256_testc_ps</code></p>
<p>Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm256_testc_ps (__m256 a, __m256 b)
VTESTPS ymm, ymm/m256</p>
<h2 id="mm256_testc_si256">mm256_testc_si256</h2>
<p><code>mm256_testc_si256</code></p>
<p>Compute the bitwise AND of 256 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm256_testc_si256 (__m256i a, __m256i b)
VPTEST ymm, ymm/m256</p>
<h2 id="mm256_testnzc_pd">mm256_testnzc_pd</h2>
<p><code>mm256_testnzc_pd</code></p>
<p>Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm256_testnzc_pd (__m256d a, __m256d b)
VTESTPD ymm, ymm/m256</p>
<h2 id="mm256_testnzc_ps">mm256_testnzc_ps</h2>
<p><code>mm256_testnzc_ps</code></p>
<p>Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm256_testnzc_ps (__m256 a, __m256 b)
VTESTPS ymm, ymm/m256</p>
<h2 id="mm256_testnzc_si256">mm256_testnzc_si256</h2>
<p><code>mm256_testnzc_si256</code></p>
<p>Compute the bitwise AND of 256 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm256_testnzc_si256 (__m256i a, __m256i b)
VPTEST ymm, ymm/m256</p>
<h2 id="mm256_testz_pd">mm256_testz_pd</h2>
<p><code>mm256_testz_pd</code></p>
<p>Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm256_testz_pd (__m256d a, __m256d b)
VTESTPD ymm, ymm/m256</p>
<h2 id="mm256_testz_ps">mm256_testz_ps</h2>
<p><code>mm256_testz_ps</code></p>
<p>Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 256-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm256_testz_ps (__m256 a, __m256 b)
VTESTPS ymm, ymm/m256</p>
<h2 id="mm256_testz_si256">mm256_testz_si256</h2>
<p><code>mm256_testz_si256</code></p>
<p>Compute the bitwise AND of 256 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm256_testz_si256 (__m256i a, __m256i b)
VPTEST ymm, ymm/m256</p>
<h2 id="mm256_unpackhi_pd">mm256_unpackhi_pd</h2>
<p><code>mm256_unpackhi_pd</code></p>
<p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_unpackhi_pd (__m256d a, __m256d b)
VUNPCKHPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_unpackhi_ps">mm256_unpackhi_ps</h2>
<p><code>mm256_unpackhi_ps</code></p>
<p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_unpackhi_ps (__m256 a, __m256 b)
VUNPCKHPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_unpacklo_pd">mm256_unpacklo_pd</h2>
<p><code>mm256_unpacklo_pd</code></p>
<p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_unpacklo_pd (__m256d a, __m256d b)
VUNPCKLPD ymm, ymm, ymm/m256</p>
<h2 id="mm256_unpacklo_ps">mm256_unpacklo_ps</h2>
<p><code>mm256_unpacklo_ps</code></p>
<p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_unpacklo_ps (__m256 a, __m256 b)
VUNPCKLPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_xor_pd">mm256_xor_pd</h2>
<p><code>mm256_xor_pd</code></p>
<p>Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256d _mm256_xor_pd (__m256d a, __m256d b)
VXORPS ymm, ymm, ymm/m256</p>
<h2 id="mm256_xor_ps">mm256_xor_ps</h2>
<p><code>mm256_xor_ps</code></p>
<p>Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m256 _mm256_xor_ps (__m256 a, __m256 b)
VXORPS ymm, ymm, ymm/m256</p>
<h2 id="mm_broadcast_ss">mm_broadcast_ss</h2>
<p><code>mm_broadcast_ss</code></p>
<p>Broadcast a single-precision (32-bit) floating-point element from memory to all elements of &quot;dst&quot;.</p>
<p>__m128 _mm_broadcast_ss (float const * mem_addr)
VBROADCASTSS xmm, m32</p>
<h2 id="mm_cmp_pd">mm_cmp_pd</h2>
<p><code>mm_cmp_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmp_pd (__m128d a, __m128d b, const int imm8)
VCMPPD xmm, xmm, xmm/m128, imm8</p>
<h2 id="mm_cmp_ps">mm_cmp_ps</h2>
<p><code>mm_cmp_ps</code></p>
<p>Compare packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_cmp_ps (__m128 a, __m128 b, const int imm8)
VCMPPS xmm, xmm, xmm/m128, imm8</p>
<h2 id="mm_cmp_sd">mm_cmp_sd</h2>
<p><code>mm_cmp_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8)
VCMPSS xmm, xmm, xmm/m32, imm8</p>
<h2 id="mm_cmp_ss">mm_cmp_ss</h2>
<p><code>mm_cmp_ss</code></p>
<p>Compare the lower single-precision (32-bit) floating-point element in &quot;a&quot; and &quot;b&quot; based on the comparison operand specified by &quot;imm8&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8)
VCMPSD xmm, xmm, xmm/m64, imm8</p>
<h2 id="mm_maskload_pd">mm_maskload_pd</h2>
<p><code>mm_maskload_pd</code></p>
<p>Load packed double-precision (64-bit) floating-point elements from memory into &quot;dst&quot; using &quot;mask&quot; (elements are zeroed out when the high bit of the corresponding element is not set).</p>
<p>__m128d _mm_maskload_pd (double const * mem_addr, __m128i mask)
VMASKMOVPD xmm, xmm, m128</p>
<h2 id="mm_maskload_ps">mm_maskload_ps</h2>
<p><code>mm_maskload_ps</code></p>
<p>Load packed single-precision (32-bit) floating-point elements from memory into &quot;dst&quot; using &quot;mask&quot; (elements are zeroed out when the high bit of the corresponding element is not set).</p>
<p>__m128 _mm_maskload_ps (float const * mem_addr, __m128i mask)
VMASKMOVPS xmm, xmm, m128</p>
<h2 id="mm_maskstore_pd">mm_maskstore_pd</h2>
<p><code>mm_maskstore_pd</code></p>
<p>Store packed double-precision (64-bit) floating-point elements from &quot;a&quot; into memory using &quot;mask&quot;.</p>
<p>void _mm_maskstore_pd (double * mem_addr, __m128i mask, __m128d a)
VMASKMOVPD m128, xmm, xmm</p>
<h2 id="mm_maskstore_ps">mm_maskstore_ps</h2>
<p><code>mm_maskstore_ps</code></p>
<p>Store packed single-precision (32-bit) floating-point elements from &quot;a&quot; into memory using &quot;mask&quot;.</p>
<p>void _mm_maskstore_ps (float * mem_addr, __m128i mask, __m128 a)
VMASKMOVPS m128, xmm, xmm</p>
<h2 id="mm_permute_pd">mm_permute_pd</h2>
<p><code>mm_permute_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements in &quot;a&quot; using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_permute_pd (__m128d a, int imm8)
VPERMILPD xmm, xmm, imm8</p>
<h2 id="mm_permute_ps">mm_permute_ps</h2>
<p><code>mm_permute_ps</code></p>
<p>Shuffle single-precision (32-bit) floating-point elements in &quot;a&quot; using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_permute_ps (__m128 a, int imm8)
VPERMILPS xmm, xmm, imm8</p>
<h2 id="mm_permutevar_pd">mm_permutevar_pd</h2>
<p><code>mm_permutevar_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements in &quot;a&quot; using the control in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_permutevar_pd (__m128d a, __m128i b)
VPERMILPD xmm, xmm, xmm/m128</p>
<h2 id="mm_permutevar_ps">mm_permutevar_ps</h2>
<p><code>mm_permutevar_ps</code></p>
<p>Shuffle single-precision (32-bit) floating-point elements in &quot;a&quot; using the control in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_permutevar_ps (__m128 a, __m128i b)
VPERMILPS xmm, xmm, xmm/m128</p>
<h2 id="mm_testc_pd">mm_testc_pd</h2>
<p><code>mm_testc_pd</code></p>
<p>Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm_testc_pd (__m128d a, __m128d b)
VTESTPD xmm, xmm/m128</p>
<h2 id="mm_testc_ps">mm_testc_ps</h2>
<p><code>mm_testc_ps</code></p>
<p>Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm_testc_ps (__m128 a, __m128 b)
VTESTPS xmm, xmm/m128</p>
<h2 id="mm_testnzc_pd">mm_testnzc_pd</h2>
<p><code>mm_testnzc_pd</code></p>
<p>Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm_testnzc_pd (__m128d a, __m128d b)
VTESTPD xmm, xmm/m128</p>
<h2 id="mm_testnzc_ps">mm_testnzc_ps</h2>
<p><code>mm_testnzc_ps</code></p>
<p>Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm_testnzc_ps (__m128 a, __m128 b)
VTESTPS xmm, xmm/m128</p>
<h2 id="mm_testz_pd">mm_testz_pd</h2>
<p><code>mm_testz_pd</code></p>
<p>Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm_testz_pd (__m128d a, __m128d b)
VTESTPD xmm, xmm/m128</p>
<h2 id="mm_testz_ps">mm_testz_ps</h2>
<p><code>mm_testz_ps</code></p>
<p>Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in &quot;a&quot; and &quot;b&quot;, producing an intermediate 128-bit value, and set &quot;ZF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, producing an intermediate value, and set &quot;CF&quot; to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm_testz_ps (__m128 a, __m128 b)
VTESTPS xmm, xmm/m128</p>

      </div>
  </div>
</div>
        </section>
        <footer>
          <hr>
          <p>Copyright &copy; 2023, Alexandre Mutel aka <a href="https://xoofx.com">xoofx</a> - Blog content licensed under the Creative Commons <a href="http://creativecommons.org/licenses/by/2.5/">CC BY 2.5</a> | Site generated by <a href="https://github.com/lunet-io/lunet">lunet</a> hosted on <a href="https://pages.github.com/">GitHub Pages</a></p>
        </footer>
      </div>
    </div>
  </body>
</html>