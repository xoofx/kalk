<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="lunet 0.4.2.0">
    <title>Intel Sse41 Intrinsics - kalk</title>
    <link rel="stylesheet" href="/css/site.css">
    <script src="/js/site.js" ></script>
    <script src="/js/site-defer.js" defer></script>
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@xoofx">
    <meta name="twitter:title" content="Intel Sse41 Intrinsics - kalk">
    <meta name="twitter:description" content="In order to use the functions provided by this module, you need to import this module: >>> import HardwareIntrinsics These intrinsic functions are only available if your CPU supports Sse41 features. mm_blend_epi16 mm_blend_epi16 Blend packed 16-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst". __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8) PBLENDW xmm, xmm/m128 imm8 mm_blend_pd mm_blend_pd Blend packed double-precision (64-bit)...">
    <meta name="twitter:image" content="https://kalk.dev/img/twitter-banner.jpg">
    <meta name="twitter:image:alt" content="Intel Sse41 Intrinsics - kalk">    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-Z558CWX6J6" async></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-Z558CWX6J6');</script>
  </head>
  <body>

    <div id="kalk" class="container">
      <nav class="navbar navbar-expand-md navbar-light sticky-top">
        <a class="kalk-logo navbar-brand" href="/"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div id="navbarSupportedContent" class="collapse navbar-collapse justify-content-between">
<ol id='nav-id-home-0' class='navbar-nav nav-level0  '>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/' class='nav-link  '>Home</a></span>  </li>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/doc/' class='nav-link  '>Documentation</a></span>  </li>
</ol>
          <ol class="navbar-nav flex-grow-1" style="padding-right: 0.5rem;">
            <li class="nav-item w-100">
                <div class="kalk-search">
                  <label class="search-icon"><i class="fa fa-search"></i></label>
                  <select id="search-box"></select>
                </div>
            </li>
          </ol>
<ol id='nav-id-home2-0' class='navbar-nav nav-level0  flex-shrink-0'>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/download/' class='nav-link  btn btn-success'><i class="fa fa-download"></i> Download</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/sponsors/xoofx' class='nav-link  btn btn-outline-secondary'><i class="fa fa-heart-o"></i> Sponsor</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/xoofx/kalk/' class='nav-link  btn btn-info'><i class="fa fa-github"></i> GitHub</a></span>  </li>
</ol>
        </div>
      </nav>
      <div class="kalk-doc">
        <section>

<div class="container">
  <div class="row">
      <div class="col-sm-3 align-self-start sticky-top menu-sidebar">
        <ol id='menu-id-doc-0' class='menu menu-level0 collapse  show '>
  <li class='menu-item '>
    <span class='menu-item-row'><a href='/doc/' class='menu-link  '>Introduction</a></span>  </li>
  <li class='menu-item '>
    <span class='menu-item-row'><a href='/doc/user/' class='menu-link  '>User Guide</a><a href='#menu-id-doc-2' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-2' class='menu-link-show collapsed'></a></span>  <ol id='menu-id-doc-2' class='menu menu-level1 collapse  '>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/user/syntax/' class='menu-link  '>Language Syntax</a></span>    </li>
  </ol>
  </li>
  <li class='menu-item '>
    <span class='menu-item-row'><a href='/doc/api/' class='menu-link  '>API Reference</a><a href='#menu-id-doc-4' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-4' class='menu-link-show'></a></span>  <ol id='menu-id-doc-4' class='menu menu-level1 collapse  show '>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/general/' class='menu-link  '>General Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/math/' class='menu-link  '>Math Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/memory/' class='menu-link  '>Memory Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/misc/' class='menu-link  '>Misc Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/vector/' class='menu-link  '>Vector Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/types/' class='menu-link  '>Types Functions</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/all/' class='menu-link  '>All Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/csv/' class='menu-link  '>Csv Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/currencies/' class='menu-link  '>Currencies Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/files/' class='menu-link  '>Files Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/standardunits/' class='menu-link  '>StandardUnits Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/strings/' class='menu-link  '>Strings Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/web/' class='menu-link  '>Web Module</a></span>    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/intel/' class='menu-link  '>Intel Hardware Intrinsics</a><a href='#menu-id-doc-18' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-18' class='menu-link-show'></a></span>    <ol id='menu-id-doc-18' class='menu menu-level2 collapse  show '>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/aes/' class='menu-link  '>Intel Aes Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/avx/' class='menu-link  '>Intel Avx Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/avx2/' class='menu-link  '>Intel Avx2 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/bmi1/' class='menu-link  '>Intel Bmi1 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/bmi1x64/' class='menu-link  '>Intel Bmi1X64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/bmi2/' class='menu-link  '>Intel Bmi2 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/bmi2x64/' class='menu-link  '>Intel Bmi2X64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse/' class='menu-link  '>Intel Sse Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/ssex64/' class='menu-link  '>Intel SseX64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse2/' class='menu-link  '>Intel Sse2 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse2x64/' class='menu-link  '>Intel Sse2X64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse3/' class='menu-link  '>Intel Sse3 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/ssse3/' class='menu-link  '>Intel Ssse3 Intrinsics</a></span>      </li>
      <li class='menu-item  active'>
        <span class='menu-item-row'><a href='/doc/api/intel/sse41/' class='menu-link  '>Intel Sse41 Intrinsics</a></span><nav class="js-toc toc"></nav>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse41x64/' class='menu-link  '>Intel Sse41X64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse42/' class='menu-link  '>Intel Sse42 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/intel/sse42x64/' class='menu-link  '>Intel Sse42X64 Intrinsics</a></span>      </li>
    </ol>
    </li>
    <li class='menu-item '>
      <span class='menu-item-row'><a href='/doc/api/arm/' class='menu-link  '>Arm Hardware Intrinsics</a><a href='#menu-id-doc-36' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-36' class='menu-link-show collapsed'></a></span>    <ol id='menu-id-doc-36' class='menu menu-level2 collapse  '>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/advsimd/' class='menu-link  '>Arm AdvSimd Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/advsimdarm64/' class='menu-link  '>Arm AdvSimdArm64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/aes/' class='menu-link  '>Arm Aes Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/crc32/' class='menu-link  '>Arm Crc32 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/crc32arm64/' class='menu-link  '>Arm Crc32Arm64 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/sha1/' class='menu-link  '>Arm Sha1 Intrinsics</a></span>      </li>
      <li class='menu-item '>
        <span class='menu-item-row'><a href='/doc/api/arm/sha256/' class='menu-link  '>Arm Sha256 Intrinsics</a></span>      </li>
    </ol>
    </li>
  </ol>
  </li>
  <li class='menu-item '>
    <span class='menu-item-row'><a href='/doc/advanced/' class='menu-link  '>Advanced Topics</a></span>  </li>
</ol>

      </div>
      <div class="col-sm-9 js-toc-content">
        <ol class='breadcrumb'>
  <li class='breadcrumb-item '>
    <a href='/' class='breadcrumb-link  '>Home</a>  </li>
  <li class='breadcrumb-item '>
    <a href='/doc/' class='breadcrumb-link  '>Documentation</a>  </li>
  <li class='breadcrumb-item '>
    <a href='/doc/api/' class='breadcrumb-link  '>API Reference</a>  </li>
  <li class='breadcrumb-item '>
    <a href='/doc/api/intel/' class='breadcrumb-link  '>Intel Hardware Intrinsics</a>  </li>
  <li class='breadcrumb-item  active'>
    Intel Sse41 Intrinsics  </li>
</ol>

        <p id="lunet-results"></p>
        <h1>Intel Sse41 Intrinsics</h1>
<p>In order to use the functions provided by this module, you need to import this module:</p>
<pre><code class="language-kalk">&gt;&gt;&gt; import HardwareIntrinsics
</code></pre>
<div class='lunet-alert-note' role='alert'><div class='lunet-alert-note-heading'><span class='lunet-alert-note-icon'></span><span class='lunet-alert-note-heading-text'></span></div><div class='lunet-alert-note-content'>
<p>These intrinsic functions are only available if your CPU supports <code>Sse41</code> features.</p>
</div></div>
<h2 id="mm_blend_epi16">mm_blend_epi16</h2>
<p><code>mm_blend_epi16</code></p>
<p>Blend packed 16-bit integers from &quot;a&quot; and &quot;b&quot; using control mask &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8)
PBLENDW xmm, xmm/m128 imm8</p>
<h2 id="mm_blend_pd">mm_blend_pd</h2>
<p><code>mm_blend_pd</code></p>
<p>Blend packed double-precision (64-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using control mask &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8)
BLENDPD xmm, xmm/m128, imm8</p>
<h2 id="mm_blend_ps">mm_blend_ps</h2>
<p><code>mm_blend_ps</code></p>
<p>Blend packed single-precision (32-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using control mask &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_blend_ps (__m128 a, __m128 b, const int imm8)
BLENDPS xmm, xmm/m128, imm8</p>
<h2 id="mm_blendv_epi8">mm_blendv_epi8</h2>
<p><code>mm_blendv_epi8</code></p>
<p>Blend packed 8-bit integers from &quot;a&quot; and &quot;b&quot; using &quot;mask&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
PBLENDVB xmm, xmm/m128, xmm</p>
<h2 id="mm_blendv_pd">mm_blendv_pd</h2>
<p><code>mm_blendv_pd</code></p>
<p>Blend packed double-precision (64-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using &quot;mask&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_blendv_pd (__m128d a, __m128d b, __m128d mask)
BLENDVPD xmm, xmm/m128, xmm0</p>
<h2 id="mm_blendv_ps">mm_blendv_ps</h2>
<p><code>mm_blendv_ps</code></p>
<p>Blend packed single-precision (32-bit) floating-point elements from &quot;a&quot; and &quot;b&quot; using &quot;mask&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask)
BLENDVPS xmm, xmm/m128, xmm0</p>
<h2 id="mm_ceil_pd">mm_ceil_pd</h2>
<p><code>mm_ceil_pd</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; up to an integer value, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_ceil_pd (__m128d a)
ROUNDPD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_ceil_ps">mm_ceil_ps</h2>
<p><code>mm_ceil_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; up to an integer value, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_ceil_ps (__m128 a)
ROUNDPS xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_ceil_sd">mm_ceil_sd</h2>
<p><code>mm_ceil_sd</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; up to an integer value, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_ceil_sd (__m128d a, __m128d b)
ROUNDSD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_ceil_sd1">mm_ceil_sd1</h2>
<p><code>mm_ceil_sd1</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; up to an integer value, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_ceil_sd (__m128d a)
ROUNDSD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_ceil_ss">mm_ceil_ss</h2>
<p><code>mm_ceil_ss</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; up to an integer value, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_ceil_ss (__m128 a, __m128 b)
ROUNDSS xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_cmpeq_epi64">mm_cmpeq_epi64</h2>
<p><code>mm_cmpeq_epi64</code></p>
<p>Compare packed 64-bit integers in &quot;a&quot; and &quot;b&quot; for equality, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpeq_epi64 (__m128i a, __m128i b)
PCMPEQQ xmm, xmm/m128</p>
<h2 id="mm_cvtepi16_epi32">mm_cvtepi16_epi32</h2>
<p><code>mm_cvtepi16_epi32</code></p>
<p>Sign extend packed 16-bit integers in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi16_epi32 (__m128i a)
PMOVSXWD xmm, xmm/m64</p>
<h2 id="mm_cvtepi16_epi64">mm_cvtepi16_epi64</h2>
<p><code>mm_cvtepi16_epi64</code></p>
<p>Sign extend packed 16-bit integers in &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi16_epi64 (__m128i a)
PMOVSXWQ xmm, xmm/m32</p>
<h2 id="mm_cvtepi32_epi64">mm_cvtepi32_epi64</h2>
<p><code>mm_cvtepi32_epi64</code></p>
<p>Sign extend packed 32-bit integers in &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi32_epi64 (__m128i a)
PMOVSXDQ xmm, xmm/m64</p>
<h2 id="mm_cvtepi8_epi16">mm_cvtepi8_epi16</h2>
<p><code>mm_cvtepi8_epi16</code></p>
<p>Sign extend packed 8-bit integers in &quot;a&quot; to packed 16-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi8_epi16 (__m128i a)
PMOVSXBW xmm, xmm/m64</p>
<h2 id="mm_cvtepi8_epi32">mm_cvtepi8_epi32</h2>
<p><code>mm_cvtepi8_epi32</code></p>
<p>Sign extend packed 8-bit integers in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi8_epi32 (__m128i a)
PMOVSXBD xmm, xmm/m32</p>
<h2 id="mm_cvtepi8_epi64">mm_cvtepi8_epi64</h2>
<p><code>mm_cvtepi8_epi64</code></p>
<p>Sign extend packed 8-bit integers in the low 8 bytes of &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepi8_epi64 (__m128i a)
PMOVSXBQ xmm, xmm/m16</p>
<h2 id="mm_cvtepu16_epi32">mm_cvtepu16_epi32</h2>
<p><code>mm_cvtepu16_epi32</code></p>
<p>Zero extend packed unsigned 16-bit integers in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu16_epi32 (__m128i a)
PMOVZXWD xmm, xmm/m64</p>
<h2 id="mm_cvtepu16_epi64">mm_cvtepu16_epi64</h2>
<p><code>mm_cvtepu16_epi64</code></p>
<p>Zero extend packed unsigned 16-bit integers in &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu16_epi64 (__m128i a)
PMOVZXWQ xmm, xmm/m32</p>
<h2 id="mm_cvtepu32_epi64">mm_cvtepu32_epi64</h2>
<p><code>mm_cvtepu32_epi64</code></p>
<p>Zero extend packed unsigned 32-bit integers in &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu32_epi64 (__m128i a)
PMOVZXDQ xmm, xmm/m64</p>
<h2 id="mm_cvtepu8_epi16">mm_cvtepu8_epi16</h2>
<p><code>mm_cvtepu8_epi16</code></p>
<p>Zero extend packed unsigned 8-bit integers in &quot;a&quot; to packed 16-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu8_epi16 (__m128i a)
PMOVZXBW xmm, xmm/m64</p>
<h2 id="mm_cvtepu8_epi32">mm_cvtepu8_epi32</h2>
<p><code>mm_cvtepu8_epi32</code></p>
<p>Zero extend packed unsigned 8-bit integers in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu8_epi32 (__m128i a)
PMOVZXBD xmm, xmm/m32</p>
<h2 id="mm_cvtepu8_epi64">mm_cvtepu8_epi64</h2>
<p><code>mm_cvtepu8_epi64</code></p>
<p>Zero extend packed unsigned 8-bit integers in the low 8 byte sof &quot;a&quot; to packed 64-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtepu8_epi64 (__m128i a)
PMOVZXBQ xmm, xmm/m16</p>
<h2 id="mm_dp_pd">mm_dp_pd</h2>
<p><code>mm_dp_pd</code></p>
<p>Conditionally multiply the packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; using the high 4 bits in &quot;imm8&quot;, sum the four products, and conditionally store the sum in &quot;dst&quot; using the low 4 bits of &quot;imm8&quot;.</p>
<p>__m128d _mm_dp_pd (__m128d a, __m128d b, const int imm8)
DPPD xmm, xmm/m128, imm8</p>
<h2 id="mm_dp_ps">mm_dp_ps</h2>
<p><code>mm_dp_ps</code></p>
<p>Conditionally multiply the packed single-precision (32-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; using the high 4 bits in &quot;imm8&quot;, sum the four products, and conditionally store the sum in &quot;dst&quot; using the low 4 bits of &quot;imm8&quot;.</p>
<p>__m128 _mm_dp_ps (__m128 a, __m128 b, const int imm8)
DPPS xmm, xmm/m128, imm8</p>
<h2 id="mm_extract_epi32">mm_extract_epi32</h2>
<p><code>mm_extract_epi32</code></p>
<p>Extract a 32-bit integer from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in &quot;dst&quot;.</p>
<p>int _mm_extract_epi32 (__m128i a, const int imm8)
PEXTRD reg/m32, xmm, imm8</p>
<h2 id="mm_extract_epi8">mm_extract_epi8</h2>
<p><code>mm_extract_epi8</code></p>
<p>Extract an 8-bit integer from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in the lower element of &quot;dst&quot;.</p>
<p>int _mm_extract_epi8 (__m128i a, const int imm8)
PEXTRB reg/m8, xmm, imm8</p>
<h2 id="mm_extract_ps">mm_extract_ps</h2>
<p><code>mm_extract_ps</code></p>
<p>Extract a single-precision (32-bit) floating-point element from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in &quot;dst&quot;.</p>
<p>int _mm_extract_ps (__m128 a, const int imm8)
EXTRACTPS xmm, xmm/m32, imm8</p>
<h2 id="mm_floor_pd">mm_floor_pd</h2>
<p><code>mm_floor_pd</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; down to an integer value, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_floor_pd (__m128d a)
ROUNDPD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_floor_ps">mm_floor_ps</h2>
<p><code>mm_floor_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; down to an integer value, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_floor_ps (__m128 a)
ROUNDPS xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_floor_sd">mm_floor_sd</h2>
<p><code>mm_floor_sd</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; down to an integer value, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_floor_sd (__m128d a, __m128d b)
ROUNDSD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_floor_sd1">mm_floor_sd1</h2>
<p><code>mm_floor_sd1</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; down to an integer value, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_floor_sd (__m128d a)
ROUNDSD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_floor_ss">mm_floor_ss</h2>
<p><code>mm_floor_ss</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; down to an integer value, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_floor_ss (__m128 a, __m128 b)
ROUNDSS xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_insert_epi32">mm_insert_epi32</h2>
<p><code>mm_insert_epi32</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, and insert the 32-bit integer &quot;i&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m128i _mm_insert_epi32 (__m128i a, int i, const int imm8)
PINSRD xmm, reg/m32, imm8</p>
<h2 id="mm_insert_epi8">mm_insert_epi8</h2>
<p><code>mm_insert_epi8</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, and insert the lower 8-bit integer from &quot;i&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m128i _mm_insert_epi8 (__m128i a, int i, const int imm8)
PINSRB xmm, reg/m8, imm8</p>
<h2 id="mm_insert_ps">mm_insert_ps</h2>
<p><code>mm_insert_ps</code></p>
<p>Copy &quot;a&quot; to &quot;tmp&quot;, then insert a single-precision (32-bit) floating-point element from &quot;b&quot; into &quot;tmp&quot; using the control in &quot;imm8&quot;. Store &quot;tmp&quot; to &quot;dst&quot; using the mask in &quot;imm8&quot; (elements are zeroed out when the corresponding bit is set).</p>
<p>__m128 _mm_insert_ps (__m128 a, __m128 b, const int imm8)
INSERTPS xmm, xmm/m32, imm8</p>
<h2 id="mm_max_epi32">mm_max_epi32</h2>
<p><code>mm_max_epi32</code></p>
<p>Compare packed 32-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epi32 (__m128i a, __m128i b)
PMAXSD xmm, xmm/m128</p>
<h2 id="mm_max_epi8">mm_max_epi8</h2>
<p><code>mm_max_epi8</code></p>
<p>Compare packed 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epi8 (__m128i a, __m128i b)
PMAXSB xmm, xmm/m128</p>
<h2 id="mm_max_epu16">mm_max_epu16</h2>
<p><code>mm_max_epu16</code></p>
<p>Compare packed unsigned 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epu16 (__m128i a, __m128i b)
PMAXUW xmm, xmm/m128</p>
<h2 id="mm_max_epu32">mm_max_epu32</h2>
<p><code>mm_max_epu32</code></p>
<p>Compare packed unsigned 32-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epu32 (__m128i a, __m128i b)
PMAXUD xmm, xmm/m128</p>
<h2 id="mm_min_epi32">mm_min_epi32</h2>
<p><code>mm_min_epi32</code></p>
<p>Compare packed 32-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epi32 (__m128i a, __m128i b)
PMINSD xmm, xmm/m128</p>
<h2 id="mm_min_epi8">mm_min_epi8</h2>
<p><code>mm_min_epi8</code></p>
<p>Compare packed 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epi8 (__m128i a, __m128i b)
PMINSB xmm, xmm/m128</p>
<h2 id="mm_min_epu16">mm_min_epu16</h2>
<p><code>mm_min_epu16</code></p>
<p>Compare packed unsigned 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epu16 (__m128i a, __m128i b)
PMINUW xmm, xmm/m128</p>
<h2 id="mm_min_epu32">mm_min_epu32</h2>
<p><code>mm_min_epu32</code></p>
<p>Compare packed unsigned 32-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epu32 (__m128i a, __m128i b)
PMINUD xmm, xmm/m128</p>
<h2 id="mm_minpos_epu16">mm_minpos_epu16</h2>
<p><code>mm_minpos_epu16</code></p>
<p>Horizontally compute the minimum amongst the packed unsigned 16-bit integers in &quot;a&quot;, store the minimum and index in &quot;dst&quot;, and zero the remaining bits in &quot;dst&quot;.</p>
<p>__m128i _mm_minpos_epu16 (__m128i a)
PHMINPOSUW xmm, xmm/m128</p>
<h2 id="mm_mpsadbw_epu8">mm_mpsadbw_epu8</h2>
<p><code>mm_mpsadbw_epu8</code></p>
<p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in &quot;a&quot; compared to those in &quot;b&quot;, and store the 16-bit results in &quot;dst&quot;.
Eight SADs are performed using one quadruplet from &quot;b&quot; and eight quadruplets from &quot;a&quot;. One quadruplet is selected from &quot;b&quot; starting at on the offset specified in &quot;imm8&quot;. Eight quadruplets are formed from sequential 8-bit integers selected from &quot;a&quot; starting at the offset specified in &quot;imm8&quot;.</p>
<p>__m128i _mm_mpsadbw_epu8 (__m128i a, __m128i b, const int imm8)
MPSADBW xmm, xmm/m128, imm8</p>
<h2 id="mm_mul_epi32">mm_mul_epi32</h2>
<p><code>mm_mul_epi32</code></p>
<p>Multiply the low 32-bit integers from each packed 64-bit element in &quot;a&quot; and &quot;b&quot;, and store the signed 64-bit results in &quot;dst&quot;.</p>
<p>__m128i _mm_mul_epi32 (__m128i a, __m128i b)
PMULDQ xmm, xmm/m128</p>
<h2 id="mm_mullo_epi32">mm_mullo_epi32</h2>
<p><code>mm_mullo_epi32</code></p>
<p>Multiply the packed 32-bit integers in &quot;a&quot; and &quot;b&quot;, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in &quot;dst&quot;.</p>
<p>__m128i _mm_mullo_epi32 (__m128i a, __m128i b)
PMULLD xmm, xmm/m128</p>
<h2 id="mm_packus_epi32">mm_packus_epi32</h2>
<p><code>mm_packus_epi32</code></p>
<p>Convert packed 32-bit integers from &quot;a&quot; and &quot;b&quot; to packed 16-bit integers using unsigned saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_packus_epi32 (__m128i a, __m128i b)
PACKUSDW xmm, xmm/m128</p>
<h2 id="mm_round_pd1">mm_round_pd1</h2>
<p><code>mm_round_pd1</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_round_pd (__m128d a, _MM_FROUND_CUR_DIRECTION); ROUNDPD xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_pd1_to_nearest_integer">mm_round_pd1_to_nearest_integer</h2>
<p><code>mm_round_pd1_to_nearest_integer</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_round_pd (__m128d a, int rounding)
ROUNDPD xmm, xmm/m128, imm8(8)
_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC</p>
<h2 id="mm_round_pd1_to_negative_infinity">mm_round_pd1_to_negative_infinity</h2>
<p><code>mm_round_pd1_to_negative_infinity</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_pd1_to_positive_infinity">mm_round_pd1_to_positive_infinity</h2>
<p><code>mm_round_pd1_to_positive_infinity</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_pd1_to_zero">mm_round_pd1_to_zero</h2>
<p><code>mm_round_pd1_to_zero</code></p>
<p>Round the packed double-precision (64-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed double-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_round_ps">mm_round_ps</h2>
<p><code>mm_round_ps</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_round_ps (__m128 a, _MM_FROUND_CUR_DIRECTION); ROUNDPS xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_ps_to_nearest_integer">mm_round_ps_to_nearest_integer</h2>
<p><code>mm_round_ps_to_nearest_integer</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_round_ps (__m128 a, int rounding)
ROUNDPS xmm, xmm/m128, imm8(8)
_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC</p>
<h2 id="mm_round_ps_to_negative_infinity">mm_round_ps_to_negative_infinity</h2>
<p><code>mm_round_ps_to_negative_infinity</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_ps_to_positive_infinity">mm_round_ps_to_positive_infinity</h2>
<p><code>mm_round_ps_to_positive_infinity</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_ps_to_zero">mm_round_ps_to_zero</h2>
<p><code>mm_round_ps_to_zero</code></p>
<p>Round the packed single-precision (32-bit) floating-point elements in &quot;a&quot; using the &quot;rounding&quot; parameter, and store the results as packed single-precision floating-point elements in &quot;dst&quot;.</p>
<p>__m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_round_sd">mm_round_sd</h2>
<p><code>mm_round_sd</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_CUR_DIRECTION)
ROUNDSD xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_sd1">mm_round_sd1</h2>
<p><code>mm_round_sd1</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, _MM_FROUND_CUR_DIRECTION)
ROUNDSD xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_sd1_to_nearest_integer_scalar">mm_round_sd1_to_nearest_integer_scalar</h2>
<p><code>mm_round_sd1_to_nearest_integer_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(8)</p>
<h2 id="mm_round_sd1_to_negative_infinity_scalar">mm_round_sd1_to_negative_infinity_scalar</h2>
<p><code>mm_round_sd1_to_negative_infinity_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_sd1_to_positive_infinity_scalar">mm_round_sd1_to_positive_infinity_scalar</h2>
<p><code>mm_round_sd1_to_positive_infinity_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_sd1_to_zero_scalar">mm_round_sd1_to_zero_scalar</h2>
<p><code>mm_round_sd1_to_zero_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_round_sd_to_nearest_integer_scalar">mm_round_sd_to_nearest_integer_scalar</h2>
<p><code>mm_round_sd_to_nearest_integer_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(8)</p>
<h2 id="mm_round_sd_to_negative_infinity_scalar">mm_round_sd_to_negative_infinity_scalar</h2>
<p><code>mm_round_sd_to_negative_infinity_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_sd_to_positive_infinity_scalar">mm_round_sd_to_positive_infinity_scalar</h2>
<p><code>mm_round_sd_to_positive_infinity_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_sd_to_zero_scalar">mm_round_sd_to_zero_scalar</h2>
<p><code>mm_round_sd_to_zero_scalar</code></p>
<p>Round the lower double-precision (64-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a double-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
ROUNDSD xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_round_ss">mm_round_ss</h2>
<p><code>mm_round_ss</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_CUR_DIRECTION)
ROUNDSS xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_ss1">mm_round_ss1</h2>
<p><code>mm_round_ss1</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, _MM_FROUND_CUR_DIRECTION)
ROUNDSS xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_round_ss1_to_nearest_integer_scalar">mm_round_ss1_to_nearest_integer_scalar</h2>
<p><code>mm_round_ss1_to_nearest_integer_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(8)</p>
<h2 id="mm_round_ss1_to_negative_infinity_scalar">mm_round_ss1_to_negative_infinity_scalar</h2>
<p><code>mm_round_ss1_to_negative_infinity_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_ss1_to_positive_infinity_scalar">mm_round_ss1_to_positive_infinity_scalar</h2>
<p><code>mm_round_ss1_to_positive_infinity_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_ss1_to_zero_scalar">mm_round_ss1_to_zero_scalar</h2>
<p><code>mm_round_ss1_to_zero_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_round_ss_to_nearest_integer_scalar">mm_round_ss_to_nearest_integer_scalar</h2>
<p><code>mm_round_ss_to_nearest_integer_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(8)</p>
<h2 id="mm_round_ss_to_negative_infinity_scalar">mm_round_ss_to_negative_infinity_scalar</h2>
<p><code>mm_round_ss_to_negative_infinity_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(9)</p>
<h2 id="mm_round_ss_to_positive_infinity_scalar">mm_round_ss_to_positive_infinity_scalar</h2>
<p><code>mm_round_ss_to_positive_infinity_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(10)</p>
<h2 id="mm_round_ss_to_zero_scalar">mm_round_ss_to_zero_scalar</h2>
<p><code>mm_round_ss_to_zero_scalar</code></p>
<p>Round the lower single-precision (32-bit) floating-point element in &quot;b&quot; using the &quot;rounding&quot; parameter, store the result as a single-precision floating-point element in the lower element of &quot;dst&quot;, and copy the upper 3 packed elements from &quot;a&quot; to the upper elements of &quot;dst&quot;.</p>
<p>__m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
ROUNDSS xmm, xmm/m128, imm8(11)</p>
<h2 id="mm_stream_load_si128">mm_stream_load_si128</h2>
<p><code>mm_stream_load_si128</code></p>
<p>Load 128-bits of integer data from memory into &quot;dst&quot; using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>__m128i _mm_stream_load_si128 (const __m128i* mem_addr)
MOVNTDQA xmm, m128</p>
<h2 id="mm_testc_si128">mm_testc_si128</h2>
<p><code>mm_testc_si128</code></p>
<p>Compute the bitwise AND of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;CF&quot; value.</p>
<p>int _mm_testc_si128 (__m128i a, __m128i b)
PTEST xmm, xmm/m128</p>
<h2 id="mm_testnzc_si128">mm_testnzc_si128</h2>
<p><code>mm_testnzc_si128</code></p>
<p>Compute the bitwise AND of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return 1 if both the &quot;ZF&quot; and &quot;CF&quot; values are zero, otherwise return 0.</p>
<p>int _mm_testnzc_si128 (__m128i a, __m128i b)
PTEST xmm, xmm/m128</p>
<h2 id="mm_testz_si128">mm_testz_si128</h2>
<p><code>mm_testz_si128</code></p>
<p>Compute the bitwise AND of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and set &quot;ZF&quot; to 1 if the result is zero, otherwise set &quot;ZF&quot; to 0. Compute the bitwise NOT of &quot;a&quot; and then AND with &quot;b&quot;, and set &quot;CF&quot; to 1 if the result is zero, otherwise set &quot;CF&quot; to 0. Return the &quot;ZF&quot; value.</p>
<p>int _mm_testz_si128 (__m128i a, __m128i b)
PTEST xmm, xmm/m128</p>

      </div>
  </div>
</div>
        </section>
        <footer>
          <hr>
          <p>Copyright &copy; 2022, Alexandre Mutel aka <a href="https://xoofx.com">xoofx</a> - Blog content licensed under the Creative Commons <a href="http://creativecommons.org/licenses/by/2.5/">CC BY 2.5</a> | Site generated by <a href="https://github.com/lunet-io/lunet">lunet</a> hosted on <a href="https://pages.github.com/">GitHub Pages</a></p>
        </footer>
      </div>
    </div>
  </body>
</html>