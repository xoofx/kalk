<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="lunet 0.5.0.0">
    <title>Intel Sse2 Intrinsics - kalk</title>
    <link rel="stylesheet" href="/css/site.css">
    <script src="/js/site.js" ></script>
    <script src="/js/site-defer.js" defer></script>
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@xoofx">
    <meta name="twitter:title" content="Intel Sse2 Intrinsics - kalk">
    <meta name="twitter:description" content="kalk - calculator app">
    <meta name="twitter:image" content="https://kalk.dev/img/twitter-banner.jpg">
    <meta name="twitter:image:alt" content="Intel Sse2 Intrinsics - kalk">    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-Z558CWX6J6" async></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-Z558CWX6J6');</script>
  </head>
  <body>

    <div id="kalk" class="container">
      <nav class="navbar navbar-expand-md navbar-light sticky-top">
        <a class="kalk-logo navbar-brand" href="/"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div id="navbarSupportedContent" class="collapse navbar-collapse justify-content-between">
<ol id='nav-id-home-0' class='navbar-nav nav-level0  '>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/' class='nav-link  '>Home</a></span>  </li>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/doc/' class='nav-link  '>Documentation</a></span>  </li>
</ol>
          <ol class="navbar-nav flex-grow-1" style="padding-right: 0.5rem;">
            <li class="nav-item w-100">
                <div class="kalk-search">
                  <label class="search-icon"><i class="fa fa-search"></i></label>
                  <select id="search-box"></select>
                </div>
            </li>
          </ol>
<ol id='nav-id-home2-0' class='navbar-nav nav-level0  flex-shrink-0'>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/download/' class='nav-link  btn btn-success'><i class="fa fa-download"></i> Download</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/sponsors/xoofx' class='nav-link  btn btn-outline-secondary'><i class="fa fa-heart-o"></i> Sponsor</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='https://github.com/xoofx/kalk/' class='nav-link  btn btn-info'><i class="fa fa-github"></i> GitHub</a></span>  </li>
</ol>
        </div>
      </nav>
      <div class="kalk-doc">
        <section>

<div class="container">
  <div class="row">
      <div class="col-sm-3 align-self-start sticky-top menu-sidebar">
        <ol id='menu-id-doc-0' class='menu menu-level0 collapse  show '>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/' class='menu-link  '>Introduction</a></span>  </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/user/' class='menu-link  '>User Guide</a><a href='#menu-id-doc-2' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-2' class='menu-link-show collapsed'></a></span>  <ol id='menu-id-doc-2' class='menu menu-level1 collapse  '>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/user/syntax/' class='menu-link  '>Language Syntax</a></span>    </li>
          </ol>
          </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/api/' class='menu-link  '>API Reference</a><a href='#menu-id-doc-4' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-4' class='menu-link-show'></a></span>  <ol id='menu-id-doc-4' class='menu menu-level1 collapse  show '>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/general/' class='menu-link  '>General Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/math/' class='menu-link  '>Math Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/memory/' class='menu-link  '>Memory Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/misc/' class='menu-link  '>Misc Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/vector/' class='menu-link  '>Vector Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/types/' class='menu-link  '>Types Functions</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/all/' class='menu-link  '>All Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/csv/' class='menu-link  '>Csv Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/currencies/' class='menu-link  '>Currencies Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/files/' class='menu-link  '>Files Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/standardunits/' class='menu-link  '>StandardUnits Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/strings/' class='menu-link  '>Strings Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/web/' class='menu-link  '>Web Module</a></span>    </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/intel/' class='menu-link  '>Intel Hardware Intrinsics</a><a href='#menu-id-doc-18' role='button'  data-toggle='collapse' aria-expanded='true' aria-controls='menu-id-doc-18' class='menu-link-show'></a></span>    <ol id='menu-id-doc-18' class='menu menu-level2 collapse  show '>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/aes/' class='menu-link  '>Intel Aes Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/avx/' class='menu-link  '>Intel Avx Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/avx2/' class='menu-link  '>Intel Avx2 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi1/' class='menu-link  '>Intel Bmi1 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi1x64/' class='menu-link  '>Intel Bmi1X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi2/' class='menu-link  '>Intel Bmi2 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/bmi2x64/' class='menu-link  '>Intel Bmi2X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse/' class='menu-link  '>Intel Sse Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/ssex64/' class='menu-link  '>Intel SseX64 Intrinsics</a></span>      </li>
              <li class='menu-item  active'>
                <span class='menu-item-row'><a href='/doc/api/intel/sse2/' class='menu-link  '>Intel Sse2 Intrinsics</a></span><nav class="js-toc toc"></nav>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse2x64/' class='menu-link  '>Intel Sse2X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse3/' class='menu-link  '>Intel Sse3 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/ssse3/' class='menu-link  '>Intel Ssse3 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse41/' class='menu-link  '>Intel Sse41 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse41x64/' class='menu-link  '>Intel Sse41X64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse42/' class='menu-link  '>Intel Sse42 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/intel/sse42x64/' class='menu-link  '>Intel Sse42X64 Intrinsics</a></span>      </li>
            </ol>
            </li>
            <li class='menu-item '>
              <span class='menu-item-row'><a href='/doc/api/arm/' class='menu-link  '>Arm Hardware Intrinsics</a><a href='#menu-id-doc-36' role='button'  data-toggle='collapse' aria-expanded='false' aria-controls='menu-id-doc-36' class='menu-link-show collapsed'></a></span>    <ol id='menu-id-doc-36' class='menu menu-level2 collapse  '>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/advsimd/' class='menu-link  '>Arm AdvSimd Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/advsimdarm64/' class='menu-link  '>Arm AdvSimdArm64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/aes/' class='menu-link  '>Arm Aes Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/crc32/' class='menu-link  '>Arm Crc32 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/crc32arm64/' class='menu-link  '>Arm Crc32Arm64 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/sha1/' class='menu-link  '>Arm Sha1 Intrinsics</a></span>      </li>
              <li class='menu-item '>
                <span class='menu-item-row'><a href='/doc/api/arm/sha256/' class='menu-link  '>Arm Sha256 Intrinsics</a></span>      </li>
            </ol>
            </li>
          </ol>
          </li>
          <li class='menu-item '>
            <span class='menu-item-row'><a href='/doc/advanced/' class='menu-link  '>Advanced Topics</a></span>  </li>
        </ol>

      </div>
      <div class="col-sm-9 js-toc-content">
        <ol class='breadcrumb'>
          <li class='breadcrumb-item '>
            <a href='/' class='breadcrumb-link  '>Home</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/' class='breadcrumb-link  '>Documentation</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/api/' class='breadcrumb-link  '>API Reference</a>  </li>
          <li class='breadcrumb-item '>
            <a href='/doc/api/intel/' class='breadcrumb-link  '>Intel Hardware Intrinsics</a>  </li>
          <li class='breadcrumb-item  active'>
            Intel Sse2 Intrinsics  </li>
        </ol>

        <p id="lunet-results"></p>
        <h1>Intel Sse2 Intrinsics</h1>
<p>In order to use the functions provided by this module, you need to import this module:</p>
<pre><code class="language-kalk">&gt;&gt;&gt; import HardwareIntrinsics
</code></pre>
<div class='lunet-alert-note' role='alert'><div class='lunet-alert-note-heading'><span class='lunet-alert-note-icon'></span><span class='lunet-alert-note-heading-text'></span></div><div class='lunet-alert-note-content'>
<p>These intrinsic functions are only available if your CPU supports <code>Sse2</code> features.</p>
</div></div>
<h2 id="mm_add_epi16">mm_add_epi16</h2>
<p><code>mm_add_epi16</code></p>
<p>Add packed 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_add_epi16 (__m128i a,  __m128i b)
PADDW xmm, xmm/m128</p>
<h2 id="mm_add_epi32">mm_add_epi32</h2>
<p><code>mm_add_epi32</code></p>
<p>Add packed 32-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_add_epi32 (__m128i a,  __m128i b)
PADDD xmm, xmm/m128</p>
<h2 id="mm_add_epi64">mm_add_epi64</h2>
<p><code>mm_add_epi64</code></p>
<p>Add packed 64-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_add_epi64 (__m128i a,  __m128i b)
PADDQ xmm, xmm/m128</p>
<h2 id="mm_add_epi8">mm_add_epi8</h2>
<p><code>mm_add_epi8</code></p>
<p>Add packed 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_add_epi8 (__m128i a,  __m128i b)
PADDB xmm, xmm/m128</p>
<h2 id="mm_add_pd">mm_add_pd</h2>
<p><code>mm_add_pd</code></p>
<p>Add packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_add_pd (__m128d a,  __m128d b)
ADDPD xmm, xmm/m128</p>
<h2 id="mm_add_sd">mm_add_sd</h2>
<p><code>mm_add_sd</code></p>
<p>Add the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_add_sd (__m128d a,  __m128d b)
ADDSD xmm, xmm/m64</p>
<h2 id="mm_adds_epi16">mm_adds_epi16</h2>
<p><code>mm_adds_epi16</code></p>
<p>Add packed 16-bit integers in &quot;a&quot; and &quot;b&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_adds_epi16 (__m128i a,  __m128i b)
PADDSW xmm, xmm/m128</p>
<h2 id="mm_adds_epi8">mm_adds_epi8</h2>
<p><code>mm_adds_epi8</code></p>
<p>Add packed 8-bit integers in &quot;a&quot; and &quot;b&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_adds_epi8 (__m128i a,  __m128i b)
PADDSB xmm, xmm/m128</p>
<h2 id="mm_adds_epu16">mm_adds_epu16</h2>
<p><code>mm_adds_epu16</code></p>
<p>Add packed unsigned 16-bit integers in &quot;a&quot; and &quot;b&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_adds_epu16 (__m128i a,  __m128i b)
PADDUSW xmm, xmm/m128</p>
<h2 id="mm_adds_epu8">mm_adds_epu8</h2>
<p><code>mm_adds_epu8</code></p>
<p>Add packed unsigned 8-bit integers in &quot;a&quot; and &quot;b&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_adds_epu8 (__m128i a,  __m128i b)
PADDUSB xmm, xmm/m128</p>
<h2 id="mm_and_pd">mm_and_pd</h2>
<p><code>mm_and_pd</code></p>
<p>Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_and_pd (__m128d a, __m128d b)
ANDPD xmm, xmm/m128</p>
<h2 id="mm_and_si128">mm_and_si128</h2>
<p><code>mm_and_si128</code></p>
<p>Compute the bitwise AND of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128i _mm_and_si128 (__m128i a,  __m128i b)
PAND xmm, xmm/m128</p>
<h2 id="mm_andnot_pd">mm_andnot_pd</h2>
<p><code>mm_andnot_pd</code></p>
<p>Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and then AND with &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_andnot_pd (__m128d a, __m128d b)
ADDNPD xmm, xmm/m128</p>
<h2 id="mm_andnot_si128">mm_andnot_si128</h2>
<p><code>mm_andnot_si128</code></p>
<p>Compute the bitwise NOT of 128 bits (representing integer data) in &quot;a&quot; and then AND with &quot;b&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128i _mm_andnot_si128 (__m128i a,  __m128i b)
PANDN xmm, xmm/m128</p>
<h2 id="mm_avg_epu16">mm_avg_epu16</h2>
<p><code>mm_avg_epu16</code></p>
<p>Average packed unsigned 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_avg_epu16 (__m128i a,  __m128i b)
PAVGW xmm, xmm/m128</p>
<h2 id="mm_avg_epu8">mm_avg_epu8</h2>
<p><code>mm_avg_epu8</code></p>
<p>Average packed unsigned 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_avg_epu8 (__m128i a,  __m128i b)
PAVGB xmm, xmm/m128</p>
<h2 id="mm_bslli_si128">mm_bslli_si128</h2>
<p><code>mm_bslli_si128</code></p>
<p>Shift &quot;a&quot; left by &quot;imm8&quot; bytes while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_bslli_si128 (__m128i a, int imm8)
PSLLDQ xmm, imm8</p>
<h2 id="mm_bsrli_si128">mm_bsrli_si128</h2>
<p><code>mm_bsrli_si128</code></p>
<p>Shift &quot;a&quot; right by &quot;imm8&quot; bytes while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_bsrli_si128 (__m128i a, int imm8)
PSRLDQ xmm, imm8</p>
<h2 id="mm_cmpeq_epi16">mm_cmpeq_epi16</h2>
<p><code>mm_cmpeq_epi16</code></p>
<p>Compare packed 16-bit integers in &quot;a&quot; and &quot;b&quot; for equality, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpeq_epi16 (__m128i a,  __m128i b)
PCMPEQW xmm, xmm/m128</p>
<h2 id="mm_cmpeq_epi32">mm_cmpeq_epi32</h2>
<p><code>mm_cmpeq_epi32</code></p>
<p>Compare packed 32-bit integers in &quot;a&quot; and &quot;b&quot; for equality, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpeq_epi32 (__m128i a,  __m128i b)
PCMPEQD xmm, xmm/m128</p>
<h2 id="mm_cmpeq_epi8">mm_cmpeq_epi8</h2>
<p><code>mm_cmpeq_epi8</code></p>
<p>Compare packed 8-bit integers in &quot;a&quot; and &quot;b&quot; for equality, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpeq_epi8 (__m128i a,  __m128i b)
PCMPEQB xmm, xmm/m128</p>
<h2 id="mm_cmpeq_pd">mm_cmpeq_pd</h2>
<p><code>mm_cmpeq_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for equality, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpeq_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(0)</p>
<h2 id="mm_cmpeq_sd">mm_cmpeq_sd</h2>
<p><code>mm_cmpeq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for equality, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpeq_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(0)</p>
<h2 id="mm_cmpge_pd">mm_cmpge_pd</h2>
<p><code>mm_cmpge_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for greater-than-or-equal, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpge_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(5)</p>
<h2 id="mm_cmpge_sd">mm_cmpge_sd</h2>
<p><code>mm_cmpge_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for greater-than-or-equal, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpge_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(5)</p>
<h2 id="mm_cmpgt_epi16">mm_cmpgt_epi16</h2>
<p><code>mm_cmpgt_epi16</code></p>
<p>Compare packed 16-bit integers in &quot;a&quot; and &quot;b&quot; for greater-than, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpgt_epi16 (__m128i a,  __m128i b)
PCMPGTW xmm, xmm/m128</p>
<h2 id="mm_cmpgt_epi32">mm_cmpgt_epi32</h2>
<p><code>mm_cmpgt_epi32</code></p>
<p>Compare packed 32-bit integers in &quot;a&quot; and &quot;b&quot; for greater-than, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpgt_epi32 (__m128i a,  __m128i b)
PCMPGTD xmm, xmm/m128</p>
<h2 id="mm_cmpgt_epi8">mm_cmpgt_epi8</h2>
<p><code>mm_cmpgt_epi8</code></p>
<p>Compare packed 8-bit integers in &quot;a&quot; and &quot;b&quot; for greater-than, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cmpgt_epi8 (__m128i a,  __m128i b)
PCMPGTB xmm, xmm/m128</p>
<h2 id="mm_cmpgt_pd">mm_cmpgt_pd</h2>
<p><code>mm_cmpgt_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for greater-than, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpgt_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(6)</p>
<h2 id="mm_cmpgt_sd">mm_cmpgt_sd</h2>
<p><code>mm_cmpgt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for greater-than, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpgt_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(6)</p>
<h2 id="mm_cmple_pd">mm_cmple_pd</h2>
<p><code>mm_cmple_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for less-than-or-equal, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmple_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(2)</p>
<h2 id="mm_cmple_sd">mm_cmple_sd</h2>
<p><code>mm_cmple_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for less-than-or-equal, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmple_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(2)</p>
<h2 id="mm_cmplt_epi16">mm_cmplt_epi16</h2>
<p><code>mm_cmplt_epi16</code></p>
<p>Compare packed 16-bit integers in &quot;a&quot; and &quot;b&quot; for less-than, and store the results in &quot;dst&quot;. Note: This intrinsic emits the pcmpgtw instruction with the order of the operands switched.</p>
<p>__m128i _mm_cmplt_epi16 (__m128i a,  __m128i b)
PCMPGTW xmm, xmm/m128</p>
<h2 id="mm_cmplt_epi32">mm_cmplt_epi32</h2>
<p><code>mm_cmplt_epi32</code></p>
<p>Compare packed 32-bit integers in &quot;a&quot; and &quot;b&quot; for less-than, and store the results in &quot;dst&quot;. Note: This intrinsic emits the pcmpgtd instruction with the order of the operands switched.</p>
<p>__m128i _mm_cmplt_epi32 (__m128i a,  __m128i b)
PCMPGTD xmm, xmm/m128</p>
<h2 id="mm_cmplt_epi8">mm_cmplt_epi8</h2>
<p><code>mm_cmplt_epi8</code></p>
<p>Compare packed 8-bit integers in &quot;a&quot; and &quot;b&quot; for less-than, and store the results in &quot;dst&quot;. Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.</p>
<p>__m128i _mm_cmplt_epi8 (__m128i a,  __m128i b)
PCMPGTB xmm, xmm/m128</p>
<h2 id="mm_cmplt_pd">mm_cmplt_pd</h2>
<p><code>mm_cmplt_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for less-than, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmplt_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(1)</p>
<h2 id="mm_cmplt_sd">mm_cmplt_sd</h2>
<p><code>mm_cmplt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for less-than, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmplt_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(1)</p>
<h2 id="mm_cmpneq_pd">mm_cmpneq_pd</h2>
<p><code>mm_cmpneq_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-equal, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpneq_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(4)</p>
<h2 id="mm_cmpneq_sd">mm_cmpneq_sd</h2>
<p><code>mm_cmpneq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-equal, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpneq_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(4)</p>
<h2 id="mm_cmpnge_pd">mm_cmpnge_pd</h2>
<p><code>mm_cmpnge_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-greater-than-or-equal, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnge_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(1)</p>
<h2 id="mm_cmpnge_sd">mm_cmpnge_sd</h2>
<p><code>mm_cmpnge_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-greater-than-or-equal, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnge_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(1)</p>
<h2 id="mm_cmpngt_pd">mm_cmpngt_pd</h2>
<p><code>mm_cmpngt_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-greater-than, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpngt_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(2)</p>
<h2 id="mm_cmpngt_sd">mm_cmpngt_sd</h2>
<p><code>mm_cmpngt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-greater-than, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpngt_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(2)</p>
<h2 id="mm_cmpnle_pd">mm_cmpnle_pd</h2>
<p><code>mm_cmpnle_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-less-than-or-equal, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnle_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(6)</p>
<h2 id="mm_cmpnle_sd">mm_cmpnle_sd</h2>
<p><code>mm_cmpnle_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-less-than-or-equal, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnle_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(6)</p>
<h2 id="mm_cmpnlt_pd">mm_cmpnlt_pd</h2>
<p><code>mm_cmpnlt_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-less-than, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnlt_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(5)</p>
<h2 id="mm_cmpnlt_sd">mm_cmpnlt_sd</h2>
<p><code>mm_cmpnlt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; for not-less-than, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpnlt_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(5)</p>
<h2 id="mm_cmpord_pd">mm_cmpord_pd</h2>
<p><code>mm_cmpord_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; to see if neither is NaN, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpord_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(7)</p>
<h2 id="mm_cmpord_sd">mm_cmpord_sd</h2>
<p><code>mm_cmpord_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; to see if neither is NaN, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpord_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(7)</p>
<h2 id="mm_cmpunord_pd">mm_cmpunord_pd</h2>
<p><code>mm_cmpunord_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; to see if either is NaN, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cmpunord_pd (__m128d a,  __m128d b)
CMPPD xmm, xmm/m128, imm8(3)</p>
<h2 id="mm_cmpunord_sd">mm_cmpunord_sd</h2>
<p><code>mm_cmpunord_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot; to see if either is NaN, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cmpunord_sd (__m128d a,  __m128d b)
CMPSD xmm, xmm/m64, imm8(3)</p>
<h2 id="mm_comieq_sd">mm_comieq_sd</h2>
<p><code>mm_comieq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for equality, and return the boolean result (0 or 1).</p>
<p>int _mm_comieq_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_comige_sd">mm_comige_sd</h2>
<p><code>mm_comige_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for greater-than-or-equal, and return the boolean result (0 or 1).</p>
<p>int _mm_comige_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_comigt_sd">mm_comigt_sd</h2>
<p><code>mm_comigt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for greater-than, and return the boolean result (0 or 1).</p>
<p>int _mm_comigt_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_comile_sd">mm_comile_sd</h2>
<p><code>mm_comile_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for less-than-or-equal, and return the boolean result (0 or 1).</p>
<p>int _mm_comile_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_comilt_sd">mm_comilt_sd</h2>
<p><code>mm_comilt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for less-than, and return the boolean result (0 or 1).</p>
<p>int _mm_comilt_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_comineq_sd">mm_comineq_sd</h2>
<p><code>mm_comineq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for not-equal, and return the boolean result (0 or 1).</p>
<p>int _mm_comineq_sd (__m128d a, __m128d b)
COMISD xmm, xmm/m64</p>
<h2 id="mm_cvtepi32_pd">mm_cvtepi32_pd</h2>
<p><code>mm_cvtepi32_pd</code></p>
<p>Convert packed 32-bit integers in &quot;a&quot; to packed double-precision (64-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cvtepi32_pd (__m128i a)
CVTDQ2PD xmm, xmm/m128</p>
<h2 id="mm_cvtepi32_ps">mm_cvtepi32_ps</h2>
<p><code>mm_cvtepi32_ps</code></p>
<p>Convert packed 32-bit integers in &quot;a&quot; to packed single-precision (32-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_cvtepi32_ps (__m128i a)
CVTDQ2PS xmm, xmm/m128</p>
<h2 id="mm_cvtpd_epi32">mm_cvtpd_epi32</h2>
<p><code>mm_cvtpd_epi32</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtpd_epi32 (__m128d a)
CVTPD2DQ xmm, xmm/m128</p>
<h2 id="mm_cvtpd_ps">mm_cvtpd_ps</h2>
<p><code>mm_cvtpd_ps</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed single-precision (32-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m128 _mm_cvtpd_ps (__m128d a)
CVTPD2PS xmm, xmm/m128</p>
<h2 id="mm_cvtps_epi32">mm_cvtps_epi32</h2>
<p><code>mm_cvtps_epi32</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvtps_epi32 (__m128 a)
CVTPS2DQ xmm, xmm/m128</p>
<h2 id="mm_cvtps_pd">mm_cvtps_pd</h2>
<p><code>mm_cvtps_pd</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed double-precision (64-bit) floating-point elements, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_cvtps_pd (__m128 a)
CVTPS2PD xmm, xmm/m128</p>
<h2 id="mm_cvtsd_si32">mm_cvtsd_si32</h2>
<p><code>mm_cvtsd_si32</code></p>
<p>Convert the lower double-precision (64-bit) floating-point element in &quot;a&quot; to a 32-bit integer, and store the result in &quot;dst&quot;.</p>
<p>int _mm_cvtsd_si32 (__m128d a)
CVTSD2SI r32, xmm/m64</p>
<h2 id="mm_cvtsd_ss">mm_cvtsd_ss</h2>
<p><code>mm_cvtsd_ss</code></p>
<p>Convert the lower double-precision (64-bit) floating-point element in &quot;b&quot; to a single-precision (32-bit) floating-point element, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128 _mm_cvtsd_ss (__m128 a, __m128d b)
CVTSD2SS xmm, xmm/m64</p>
<h2 id="mm_cvtsi128_si32">mm_cvtsi128_si32</h2>
<p><code>mm_cvtsi128_si32</code></p>
<p>Copy the lower 32-bit integer in &quot;a&quot; to &quot;dst&quot;.</p>
<p>int _mm_cvtsi128_si32 (__m128i a)
MOVD reg/m32, xmm</p>
<h2 id="mm_cvtsi32_sd">mm_cvtsi32_sd</h2>
<p><code>mm_cvtsi32_sd</code></p>
<p>Convert the 32-bit integer &quot;b&quot; to a double-precision (64-bit) floating-point element, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cvtsi32_sd (__m128d a, int b)
CVTSI2SD xmm, reg/m32</p>
<h2 id="mm_cvtsi32_si128">mm_cvtsi32_si128</h2>
<p><code>mm_cvtsi32_si128</code></p>
<p>Copy 32-bit integer &quot;a&quot; to the lower elements of &quot;dst&quot;, and zero the upper elements of &quot;dst&quot;.</p>
<p>__m128i _mm_cvtsi32_si128 (int a)
MOVD xmm, reg/m32</p>
<h2 id="mm_cvtss_sd">mm_cvtss_sd</h2>
<p><code>mm_cvtss_sd</code></p>
<p>Convert the lower single-precision (32-bit) floating-point element in &quot;b&quot; to a double-precision (64-bit) floating-point element, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_cvtss_sd (__m128d a, __m128 b)
CVTSS2SD xmm, xmm/m32</p>
<h2 id="mm_cvttpd_epi32">mm_cvttpd_epi32</h2>
<p><code>mm_cvttpd_epi32</code></p>
<p>Convert packed double-precision (64-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers with truncation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvttpd_epi32 (__m128d a)
CVTTPD2DQ xmm, xmm/m128</p>
<h2 id="mm_cvttps_epi32">mm_cvttps_epi32</h2>
<p><code>mm_cvttps_epi32</code></p>
<p>Convert packed single-precision (32-bit) floating-point elements in &quot;a&quot; to packed 32-bit integers with truncation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_cvttps_epi32 (__m128 a)
CVTTPS2DQ xmm, xmm/m128</p>
<h2 id="mm_cvttsd_si32">mm_cvttsd_si32</h2>
<p><code>mm_cvttsd_si32</code></p>
<p>Convert the lower double-precision (64-bit) floating-point element in &quot;a&quot; to a 32-bit integer with truncation, and store the result in &quot;dst&quot;.</p>
<p>int _mm_cvttsd_si32 (__m128d a)
CVTTSD2SI reg, xmm/m64</p>
<h2 id="mm_div_pd">mm_div_pd</h2>
<p><code>mm_div_pd</code></p>
<p>Divide packed double-precision (64-bit) floating-point elements in &quot;a&quot; by packed elements in &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_div_pd (__m128d a,  __m128d b)
DIVPD xmm, xmm/m128</p>
<h2 id="mm_div_sd">mm_div_sd</h2>
<p><code>mm_div_sd</code></p>
<p>Divide the lower double-precision (64-bit) floating-point element in &quot;a&quot; by the lower double-precision (64-bit) floating-point element in &quot;b&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_div_sd (__m128d a,  __m128d b)
DIVSD xmm, xmm/m64</p>
<h2 id="mm_extract_epi16">mm_extract_epi16</h2>
<p><code>mm_extract_epi16</code></p>
<p>Extract a 16-bit integer from &quot;a&quot;, selected with &quot;imm8&quot;, and store the result in the lower element of &quot;dst&quot;.</p>
<p>int _mm_extract_epi16 (__m128i a,  int immediate)
PEXTRW reg, xmm, imm8</p>
<h2 id="mm_insert_epi16">mm_insert_epi16</h2>
<p><code>mm_insert_epi16</code></p>
<p>Copy &quot;a&quot; to &quot;dst&quot;, and insert the 16-bit integer &quot;i&quot; into &quot;dst&quot; at the location specified by &quot;imm8&quot;.</p>
<p>__m128i _mm_insert_epi16 (__m128i a,  int i, int immediate)
PINSRW xmm, reg/m16, imm8</p>
<h2 id="mm_load_pd">mm_load_pd</h2>
<p><code>mm_load_pd</code></p>
<p>Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>__m128d _mm_load_pd (double const* mem_address)
MOVAPD xmm, m128</p>
<h2 id="mm_load_sd">mm_load_sd</h2>
<p><code>mm_load_sd</code></p>
<p>Load a double-precision (64-bit) floating-point element from memory into the lower of &quot;dst&quot;, and zero the upper element. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m128d _mm_load_sd (double const* mem_address)
MOVSD xmm, m64</p>
<h2 id="mm_load_si128">mm_load_si128</h2>
<p><code>mm_load_si128</code></p>
<p>Load 128-bits of integer data from memory into &quot;dst&quot;.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>__m128i _mm_load_si128 (__m128i const* mem_address)
MOVDQA xmm, m128</p>
<h2 id="mm_loadh_pd">mm_loadh_pd</h2>
<p><code>mm_loadh_pd</code></p>
<p>Load a double-precision (64-bit) floating-point element from memory into the upper element of &quot;dst&quot;, and copy the lower element from &quot;a&quot; to &quot;dst&quot;. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m128d _mm_loadh_pd (__m128d a, double const* mem_addr)
MOVHPD xmm, m64</p>
<h2 id="mm_loadl_epi32">mm_loadl_epi32</h2>
<p><code>mm_loadl_epi32</code></p>
<p>__m128i _mm_loadl_epi32 (__m128i const* mem_addr)
MOVD xmm, reg/m32</p>
<h2 id="mm_loadl_epi64">mm_loadl_epi64</h2>
<p><code>mm_loadl_epi64</code></p>
<p>Load 64-bit integer from memory into the first element of &quot;dst&quot;.</p>
<p>__m128i _mm_loadl_epi64 (__m128i const* mem_addr)
MOVQ xmm, reg/m64</p>
<h2 id="mm_loadl_pd">mm_loadl_pd</h2>
<p><code>mm_loadl_pd</code></p>
<p>Load a double-precision (64-bit) floating-point element from memory into the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to &quot;dst&quot;. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m128d _mm_loadl_pd (__m128d a, double const* mem_addr)
MOVLPD xmm, m64</p>
<h2 id="mm_loadu_pd">mm_loadu_pd</h2>
<p><code>mm_loadu_pd</code></p>
<p>Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into &quot;dst&quot;.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m128d _mm_loadu_pd (double const* mem_address)
MOVUPD xmm, m128</p>
<h2 id="mm_loadu_si128">mm_loadu_si128</h2>
<p><code>mm_loadu_si128</code></p>
<p>Load 128-bits of integer data from memory into &quot;dst&quot;.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>__m128i _mm_loadu_si128 (__m128i const* mem_address)
MOVDQU xmm, m128</p>
<h2 id="mm_madd_epi16">mm_madd_epi16</h2>
<p><code>mm_madd_epi16</code></p>
<p>Multiply packed signed 16-bit integers in &quot;a&quot; and &quot;b&quot;, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in &quot;dst&quot;.</p>
<p>__m128i _mm_madd_epi16 (__m128i a,  __m128i b)
PMADDWD xmm, xmm/m128</p>
<h2 id="mm_maskmoveu_si128">mm_maskmoveu_si128</h2>
<p><code>mm_maskmoveu_si128</code></p>
<p>Conditionally store 8-bit integer elements from &quot;a&quot; into memory using &quot;mask&quot; (elements are not stored when the highest bit is not set in the corresponding element) and a non-temporal memory hint. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm_maskmoveu_si128 (__m128i a,  __m128i mask, char* mem_address)
MASKMOVDQU xmm, xmm</p>
<h2 id="mm_max_epi16">mm_max_epi16</h2>
<p><code>mm_max_epi16</code></p>
<p>Compare packed 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epi16 (__m128i a,  __m128i b)
PMAXSW xmm, xmm/m128</p>
<h2 id="mm_max_epu8">mm_max_epu8</h2>
<p><code>mm_max_epu8</code></p>
<p>Compare packed unsigned 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128i _mm_max_epu8 (__m128i a,  __m128i b)
PMAXUB xmm, xmm/m128</p>
<h2 id="mm_max_pd">mm_max_pd</h2>
<p><code>mm_max_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed maximum values in &quot;dst&quot;.</p>
<p>__m128d _mm_max_pd (__m128d a,  __m128d b)
MAXPD xmm, xmm/m128</p>
<h2 id="mm_max_sd">mm_max_sd</h2>
<p><code>mm_max_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, store the maximum value in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_max_sd (__m128d a,  __m128d b)
MAXSD xmm, xmm/m64</p>
<h2 id="mm_min_epi16">mm_min_epi16</h2>
<p><code>mm_min_epi16</code></p>
<p>Compare packed 16-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epi16 (__m128i a,  __m128i b)
PMINSW xmm, xmm/m128</p>
<h2 id="mm_min_epu8">mm_min_epu8</h2>
<p><code>mm_min_epu8</code></p>
<p>Compare packed unsigned 8-bit integers in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128i _mm_min_epu8 (__m128i a,  __m128i b)
PMINUB xmm, xmm/m128</p>
<h2 id="mm_min_pd">mm_min_pd</h2>
<p><code>mm_min_pd</code></p>
<p>Compare packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store packed minimum values in &quot;dst&quot;.</p>
<p>__m128d _mm_min_pd (__m128d a,  __m128d b)
MINPD xmm, xmm/m128</p>
<h2 id="mm_min_sd">mm_min_sd</h2>
<p><code>mm_min_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, store the minimum value in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_min_sd (__m128d a,  __m128d b)
MINSD xmm, xmm/m64</p>
<h2 id="mm_move_epi64">mm_move_epi64</h2>
<p><code>mm_move_epi64</code></p>
<p>Copy the lower 64-bit integer in &quot;a&quot; to the lower element of &quot;dst&quot;, and zero the upper element.</p>
<p>__m128i _mm_move_epi64 (__m128i a)
MOVQ xmm, xmm</p>
<h2 id="mm_move_sd">mm_move_sd</h2>
<p><code>mm_move_sd</code></p>
<p>Move the lower double-precision (64-bit) floating-point element from &quot;b&quot; to the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_move_sd (__m128d a, __m128d b)
MOVSD xmm, xmm</p>
<h2 id="mm_movemask_epi8">mm_movemask_epi8</h2>
<p><code>mm_movemask_epi8</code></p>
<p>Create mask from the most significant bit of each 8-bit element in &quot;a&quot;, and store the result in &quot;dst&quot;.</p>
<p>int _mm_movemask_epi8 (__m128i a)
PMOVMSKB reg, xmm</p>
<h2 id="mm_movemask_pd">mm_movemask_pd</h2>
<p><code>mm_movemask_pd</code></p>
<p>Set each bit of mask &quot;dst&quot; based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in &quot;a&quot;.</p>
<p>int _mm_movemask_pd (__m128d a)
MOVMSKPD reg, xmm</p>
<h2 id="mm_mul_epu32">mm_mul_epu32</h2>
<p><code>mm_mul_epu32</code></p>
<p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in &quot;a&quot; and &quot;b&quot;, and store the unsigned 64-bit results in &quot;dst&quot;.</p>
<p>__m128i _mm_mul_epu32 (__m128i a,  __m128i b)
PMULUDQ xmm, xmm/m128</p>
<h2 id="mm_mul_pd">mm_mul_pd</h2>
<p><code>mm_mul_pd</code></p>
<p>Multiply packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_mul_pd (__m128d a,  __m128d b)
MULPD xmm, xmm/m128</p>
<h2 id="mm_mul_sd">mm_mul_sd</h2>
<p><code>mm_mul_sd</code></p>
<p>Multiply the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_mul_sd (__m128d a,  __m128d b)
MULSD xmm, xmm/m64</p>
<h2 id="mm_mulhi_epi16">mm_mulhi_epi16</h2>
<p><code>mm_mulhi_epi16</code></p>
<p>Multiply the packed 16-bit integers in &quot;a&quot; and &quot;b&quot;, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in &quot;dst&quot;.</p>
<p>__m128i _mm_mulhi_epi16 (__m128i a,  __m128i b)
PMULHW xmm, xmm/m128</p>
<h2 id="mm_mulhi_epu16">mm_mulhi_epu16</h2>
<p><code>mm_mulhi_epu16</code></p>
<p>Multiply the packed unsigned 16-bit integers in &quot;a&quot; and &quot;b&quot;, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in &quot;dst&quot;.</p>
<p>__m128i _mm_mulhi_epu16 (__m128i a,  __m128i b)
PMULHUW xmm, xmm/m128</p>
<h2 id="mm_mullo_epi16">mm_mullo_epi16</h2>
<p><code>mm_mullo_epi16</code></p>
<p>Multiply the packed 16-bit integers in &quot;a&quot; and &quot;b&quot;, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in &quot;dst&quot;.</p>
<p>__m128i _mm_mullo_epi16 (__m128i a,  __m128i b)
PMULLW xmm, xmm/m128</p>
<h2 id="mm_or_pd">mm_or_pd</h2>
<p><code>mm_or_pd</code></p>
<p>Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_or_pd (__m128d a,  __m128d b)
ORPD xmm, xmm/m128</p>
<h2 id="mm_or_si128">mm_or_si128</h2>
<p><code>mm_or_si128</code></p>
<p>Compute the bitwise OR of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128i _mm_or_si128 (__m128i a,  __m128i b)
POR xmm, xmm/m128</p>
<h2 id="mm_packs_epi16">mm_packs_epi16</h2>
<p><code>mm_packs_epi16</code></p>
<p>Convert packed 16-bit integers from &quot;a&quot; and &quot;b&quot; to packed 8-bit integers using signed saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_packs_epi16 (__m128i a,  __m128i b)
PACKSSWB xmm, xmm/m128</p>
<h2 id="mm_packs_epi32">mm_packs_epi32</h2>
<p><code>mm_packs_epi32</code></p>
<p>Convert packed 32-bit integers from &quot;a&quot; and &quot;b&quot; to packed 16-bit integers using signed saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_packs_epi32 (__m128i a,  __m128i b)
PACKSSDW xmm, xmm/m128</p>
<h2 id="mm_packus_epi16">mm_packus_epi16</h2>
<p><code>mm_packus_epi16</code></p>
<p>Convert packed 16-bit integers from &quot;a&quot; and &quot;b&quot; to packed 8-bit integers using unsigned saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_packus_epi16 (__m128i a,  __m128i b)
PACKUSWB xmm, xmm/m128</p>
<h2 id="mm_sad_epu8">mm_sad_epu8</h2>
<p><code>mm_sad_epu8</code></p>
<p>Compute the absolute differences of packed unsigned 8-bit integers in &quot;a&quot; and &quot;b&quot;, then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in &quot;dst&quot;.</p>
<p>__m128i _mm_sad_epu8 (__m128i a,  __m128i b)
PSADBW xmm, xmm/m128</p>
<h2 id="mm_shuffle_epi32">mm_shuffle_epi32</h2>
<p><code>mm_shuffle_epi32</code></p>
<p>Shuffle 32-bit integers in &quot;a&quot; using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_shuffle_epi32 (__m128i a,  int immediate)
PSHUFD xmm, xmm/m128, imm8</p>
<h2 id="mm_shuffle_pd">mm_shuffle_pd</h2>
<p><code>mm_shuffle_pd</code></p>
<p>Shuffle double-precision (64-bit) floating-point elements using the control in &quot;imm8&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_shuffle_pd (__m128d a,  __m128d b, int immediate)
SHUFPD xmm, xmm/m128, imm8</p>
<h2 id="mm_shufflehi_epi16">mm_shufflehi_epi16</h2>
<p><code>mm_shufflehi_epi16</code></p>
<p>Shuffle 16-bit integers in the high 64 bits of &quot;a&quot; using the control in &quot;imm8&quot;. Store the results in the high 64 bits of &quot;dst&quot;, with the low 64 bits being copied from from &quot;a&quot; to &quot;dst&quot;.</p>
<p>__m128i _mm_shufflehi_epi16 (__m128i a,  int immediate)
PSHUFHW xmm, xmm/m128, imm8</p>
<h2 id="mm_shufflelo_epi16">mm_shufflelo_epi16</h2>
<p><code>mm_shufflelo_epi16</code></p>
<p>Shuffle 16-bit integers in the low 64 bits of &quot;a&quot; using the control in &quot;imm8&quot;. Store the results in the low 64 bits of &quot;dst&quot;, with the high 64 bits being copied from from &quot;a&quot; to &quot;dst&quot;.</p>
<p>__m128i _mm_shufflelo_epi16 (__m128i a,  int control)
PSHUFLW xmm, xmm/m128, imm8</p>
<h2 id="mm_sll_epi16">mm_sll_epi16</h2>
<p><code>mm_sll_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; left by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sll_epi16 (__m128i a, __m128i count)
PSLLW xmm, xmm/m128</p>
<h2 id="mm_sll_epi32">mm_sll_epi32</h2>
<p><code>mm_sll_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; left by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sll_epi32 (__m128i a, __m128i count)
PSLLD xmm, xmm/m128</p>
<h2 id="mm_sll_epi64">mm_sll_epi64</h2>
<p><code>mm_sll_epi64</code></p>
<p>Shift packed 64-bit integers in &quot;a&quot; left by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sll_epi64 (__m128i a, __m128i count)
PSLLQ xmm, xmm/m128</p>
<h2 id="mm_slli_epi16">mm_slli_epi16</h2>
<p><code>mm_slli_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; left by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_slli_epi16 (__m128i a,  int immediate)
PSLLW xmm, imm8</p>
<h2 id="mm_slli_epi32">mm_slli_epi32</h2>
<p><code>mm_slli_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; left by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_slli_epi32 (__m128i a,  int immediate)
PSLLD xmm, imm8</p>
<h2 id="mm_slli_epi64">mm_slli_epi64</h2>
<p><code>mm_slli_epi64</code></p>
<p>Shift packed 64-bit integers in &quot;a&quot; left by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_slli_epi64 (__m128i a,  int immediate)
PSLLQ xmm, imm8</p>
<h2 id="mm_sqrt_pd">mm_sqrt_pd</h2>
<p><code>mm_sqrt_pd</code></p>
<p>Compute the square root of packed double-precision (64-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_sqrt_pd (__m128d a)
SQRTPD xmm, xmm/m128</p>
<h2 id="mm_sqrt_sd">mm_sqrt_sd</h2>
<p><code>mm_sqrt_sd</code></p>
<p>Compute the square root of the lower double-precision (64-bit) floating-point element in &quot;b&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_sqrt_sd (__m128d a, __m128d b)
SQRTSD xmm, xmm/64</p>
<h2 id="mm_sqrt_sd1">mm_sqrt_sd1</h2>
<p><code>mm_sqrt_sd1</code></p>
<p>Compute the square root of the lower double-precision (64-bit) floating-point element in &quot;b&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_sqrt_sd (__m128d a)
SQRTSD xmm, xmm/64</p>
<h2 id="mm_sra_epi16">mm_sra_epi16</h2>
<p><code>mm_sra_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; right by &quot;count&quot; while shifting in sign bits, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sra_epi16 (__m128i a, __m128i count)
PSRAW xmm, xmm/m128</p>
<h2 id="mm_sra_epi32">mm_sra_epi32</h2>
<p><code>mm_sra_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; right by &quot;count&quot; while shifting in sign bits, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sra_epi32 (__m128i a, __m128i count)
PSRAD xmm, xmm/m128</p>
<h2 id="mm_srai_epi16">mm_srai_epi16</h2>
<p><code>mm_srai_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; right by &quot;imm8&quot; while shifting in sign bits, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srai_epi16 (__m128i a,  int immediate)
PSRAW xmm, imm8</p>
<h2 id="mm_srai_epi32">mm_srai_epi32</h2>
<p><code>mm_srai_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; right by &quot;imm8&quot; while shifting in sign bits, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srai_epi32 (__m128i a,  int immediate)
PSRAD xmm, imm8</p>
<h2 id="mm_srl_epi16">mm_srl_epi16</h2>
<p><code>mm_srl_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; right by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srl_epi16 (__m128i a, __m128i count)
PSRLW xmm, xmm/m128</p>
<h2 id="mm_srl_epi32">mm_srl_epi32</h2>
<p><code>mm_srl_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; right by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srl_epi32 (__m128i a, __m128i count)
PSRLD xmm, xmm/m128</p>
<h2 id="mm_srl_epi64">mm_srl_epi64</h2>
<p><code>mm_srl_epi64</code></p>
<p>Shift packed 64-bit integers in &quot;a&quot; right by &quot;count&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srl_epi64 (__m128i a, __m128i count)
PSRLQ xmm, xmm/m128</p>
<h2 id="mm_srli_epi16">mm_srli_epi16</h2>
<p><code>mm_srli_epi16</code></p>
<p>Shift packed 16-bit integers in &quot;a&quot; right by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srli_epi16 (__m128i a,  int immediate)
PSRLW xmm, imm8</p>
<h2 id="mm_srli_epi32">mm_srli_epi32</h2>
<p><code>mm_srli_epi32</code></p>
<p>Shift packed 32-bit integers in &quot;a&quot; right by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srli_epi32 (__m128i a,  int immediate)
PSRLD xmm, imm8</p>
<h2 id="mm_srli_epi64">mm_srli_epi64</h2>
<p><code>mm_srli_epi64</code></p>
<p>Shift packed 64-bit integers in &quot;a&quot; right by &quot;imm8&quot; while shifting in zeros, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_srli_epi64 (__m128i a,  int immediate)
PSRLQ xmm, imm8</p>
<h2 id="mm_store_pd">mm_store_pd</h2>
<p><code>mm_store_pd</code></p>
<p>Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm_store_pd (double* mem_addr, __m128d a)
MOVAPD m128, xmm</p>
<h2 id="mm_store_sd">mm_store_sd</h2>
<p><code>mm_store_sd</code></p>
<p>Store the lower double-precision (64-bit) floating-point element from &quot;a&quot; into memory. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm_store_sd (double* mem_addr, __m128d a)
MOVSD m64, xmm</p>
<h2 id="mm_store_si128">mm_store_si128</h2>
<p><code>mm_store_si128</code></p>
<p>Store 128-bits of integer data from &quot;a&quot; into memory.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm_store_si128 (__m128i* mem_addr, __m128i a)
MOVDQA m128, xmm</p>
<h2 id="mm_storeh_pd">mm_storeh_pd</h2>
<p><code>mm_storeh_pd</code></p>
<p>Store the upper double-precision (64-bit) floating-point element from &quot;a&quot; into memory.</p>
<p>void _mm_storeh_pd (double* mem_addr, __m128d a)
MOVHPD m64, xmm</p>
<h2 id="mm_storel_epi64">mm_storel_epi64</h2>
<p><code>mm_storel_epi64</code></p>
<p>Store 64-bit integer from the first element of &quot;a&quot; into memory.</p>
<p>void _mm_storel_epi64 (__m128i* mem_addr, __m128i a)
MOVQ m64, xmm</p>
<h2 id="mm_storel_pd">mm_storel_pd</h2>
<p><code>mm_storel_pd</code></p>
<p>Store the lower double-precision (64-bit) floating-point element from &quot;a&quot; into memory.</p>
<p>void _mm_storel_pd (double* mem_addr, __m128d a)
MOVLPD m64, xmm</p>
<h2 id="mm_storeu_pd">mm_storeu_pd</h2>
<p><code>mm_storeu_pd</code></p>
<p>Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm_storeu_pd (double* mem_addr, __m128d a)
MOVUPD m128, xmm</p>
<h2 id="mm_storeu_si128">mm_storeu_si128</h2>
<p><code>mm_storeu_si128</code></p>
<p>Store 128-bits of integer data from &quot;a&quot; into memory.
&quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
MOVDQU m128, xmm</p>
<h2 id="mm_storeu_si32">mm_storeu_si32</h2>
<p><code>mm_storeu_si32</code></p>
<p>Store 32-bit integer from the first element of &quot;a&quot; into memory. &quot;mem_addr&quot; does not need to be aligned on any particular boundary.</p>
<p>void _mm_storeu_si32 (void* mem_addr, __m128i a) MOVD m32, xmm</p>
<h2 id="mm_stream_pd">mm_stream_pd</h2>
<p><code>mm_stream_pd</code></p>
<p>Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from &quot;a&quot; into memory using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm_stream_pd (double* mem_addr, __m128d a)
MOVNTPD m128, xmm</p>
<h2 id="mm_stream_si128">mm_stream_si128</h2>
<p><code>mm_stream_si128</code></p>
<p>Store 128-bits of integer data from &quot;a&quot; into memory using a non-temporal memory hint.
&quot;mem_addr&quot; must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
<p>void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
MOVNTDQ m128, xmm</p>
<h2 id="mm_stream_si32">mm_stream_si32</h2>
<p><code>mm_stream_si32</code></p>
<p>Store 32-bit integer &quot;a&quot; into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address &quot;mem_addr&quot; is already in the cache, the cache will be updated.</p>
<p>void _mm_stream_si32(int *p, int a)
MOVNTI m32, r32</p>
<h2 id="mm_sub_epi16">mm_sub_epi16</h2>
<p><code>mm_sub_epi16</code></p>
<p>Subtract packed 16-bit integers in &quot;b&quot; from packed 16-bit integers in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sub_epi16 (__m128i a,  __m128i b)
PSUBW xmm, xmm/m128</p>
<h2 id="mm_sub_epi32">mm_sub_epi32</h2>
<p><code>mm_sub_epi32</code></p>
<p>Subtract packed 32-bit integers in &quot;b&quot; from packed 32-bit integers in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sub_epi32 (__m128i a,  __m128i b)
PSUBD xmm, xmm/m128</p>
<h2 id="mm_sub_epi64">mm_sub_epi64</h2>
<p><code>mm_sub_epi64</code></p>
<p>Subtract packed 64-bit integers in &quot;b&quot; from packed 64-bit integers in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sub_epi64 (__m128i a,  __m128i b)
PSUBQ xmm, xmm/m128</p>
<h2 id="mm_sub_epi8">mm_sub_epi8</h2>
<p><code>mm_sub_epi8</code></p>
<p>Subtract packed 8-bit integers in &quot;b&quot; from packed 8-bit integers in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_sub_epi8 (__m128i a,  __m128i b)
PSUBB xmm, xmm/m128</p>
<h2 id="mm_sub_pd">mm_sub_pd</h2>
<p><code>mm_sub_pd</code></p>
<p>Subtract packed double-precision (64-bit) floating-point elements in &quot;b&quot; from packed double-precision (64-bit) floating-point elements in &quot;a&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_sub_pd (__m128d a, __m128d b)
SUBPD xmm, xmm/m128</p>
<h2 id="mm_sub_sd">mm_sub_sd</h2>
<p><code>mm_sub_sd</code></p>
<p>Subtract the lower double-precision (64-bit) floating-point element in &quot;b&quot; from the lower double-precision (64-bit) floating-point element in &quot;a&quot;, store the result in the lower element of &quot;dst&quot;, and copy the upper element from &quot;a&quot; to the upper element of &quot;dst&quot;.</p>
<p>__m128d _mm_sub_sd (__m128d a, __m128d b)
SUBSD xmm, xmm/m64</p>
<h2 id="mm_subs_epi16">mm_subs_epi16</h2>
<p><code>mm_subs_epi16</code></p>
<p>Subtract packed 16-bit integers in &quot;b&quot; from packed 16-bit integers in &quot;a&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_subs_epi16 (__m128i a,  __m128i b)
PSUBSW xmm, xmm/m128</p>
<h2 id="mm_subs_epi8">mm_subs_epi8</h2>
<p><code>mm_subs_epi8</code></p>
<p>Subtract packed 8-bit integers in &quot;b&quot; from packed 8-bit integers in &quot;a&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_subs_epi8 (__m128i a,  __m128i b)
PSUBSB xmm, xmm/m128</p>
<h2 id="mm_subs_epu16">mm_subs_epu16</h2>
<p><code>mm_subs_epu16</code></p>
<p>Subtract packed unsigned 16-bit integers in &quot;b&quot; from packed unsigned 16-bit integers in &quot;a&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_subs_epu16 (__m128i a,  __m128i b)
PSUBUSW xmm, xmm/m128</p>
<h2 id="mm_subs_epu8">mm_subs_epu8</h2>
<p><code>mm_subs_epu8</code></p>
<p>Subtract packed unsigned 8-bit integers in &quot;b&quot; from packed unsigned 8-bit integers in &quot;a&quot; using saturation, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_subs_epu8 (__m128i a,  __m128i b)
PSUBUSB xmm, xmm/m128</p>
<h2 id="mm_ucomieq_sd">mm_ucomieq_sd</h2>
<p><code>mm_ucomieq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomieq_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_ucomige_sd">mm_ucomige_sd</h2>
<p><code>mm_ucomige_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomige_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_ucomigt_sd">mm_ucomigt_sd</h2>
<p><code>mm_ucomigt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomigt_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_ucomile_sd">mm_ucomile_sd</h2>
<p><code>mm_ucomile_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomile_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_ucomilt_sd">mm_ucomilt_sd</h2>
<p><code>mm_ucomilt_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomilt_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_ucomineq_sd">mm_ucomineq_sd</h2>
<p><code>mm_ucomineq_sd</code></p>
<p>Compare the lower double-precision (64-bit) floating-point element in &quot;a&quot; and &quot;b&quot; for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.</p>
<p>int _mm_ucomineq_sd (__m128d a, __m128d b)
UCOMISD xmm, xmm/m64</p>
<h2 id="mm_unpackhi_epi16">mm_unpackhi_epi16</h2>
<p><code>mm_unpackhi_epi16</code></p>
<p>Unpack and interleave 16-bit integers from the high half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpackhi_epi16 (__m128i a,  __m128i b)
PUNPCKHWD xmm, xmm/m128</p>
<h2 id="mm_unpackhi_epi32">mm_unpackhi_epi32</h2>
<p><code>mm_unpackhi_epi32</code></p>
<p>Unpack and interleave 32-bit integers from the high half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpackhi_epi32 (__m128i a,  __m128i b)
PUNPCKHDQ xmm, xmm/m128</p>
<h2 id="mm_unpackhi_epi64">mm_unpackhi_epi64</h2>
<p><code>mm_unpackhi_epi64</code></p>
<p>Unpack and interleave 64-bit integers from the high half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpackhi_epi64 (__m128i a,  __m128i b)
PUNPCKHQDQ xmm, xmm/m128</p>
<h2 id="mm_unpackhi_epi8">mm_unpackhi_epi8</h2>
<p><code>mm_unpackhi_epi8</code></p>
<p>Unpack and interleave 8-bit integers from the high half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpackhi_epi8 (__m128i a,  __m128i b)
PUNPCKHBW xmm, xmm/m128</p>
<h2 id="mm_unpackhi_pd">mm_unpackhi_pd</h2>
<p><code>mm_unpackhi_pd</code></p>
<p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_unpackhi_pd (__m128d a,  __m128d b)
UNPCKHPD xmm, xmm/m128</p>
<h2 id="mm_unpacklo_epi16">mm_unpacklo_epi16</h2>
<p><code>mm_unpacklo_epi16</code></p>
<p>Unpack and interleave 16-bit integers from the low half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpacklo_epi16 (__m128i a,  __m128i b)
PUNPCKLWD xmm, xmm/m128</p>
<h2 id="mm_unpacklo_epi32">mm_unpacklo_epi32</h2>
<p><code>mm_unpacklo_epi32</code></p>
<p>Unpack and interleave 32-bit integers from the low half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpacklo_epi32 (__m128i a,  __m128i b)
PUNPCKLDQ xmm, xmm/m128</p>
<h2 id="mm_unpacklo_epi64">mm_unpacklo_epi64</h2>
<p><code>mm_unpacklo_epi64</code></p>
<p>Unpack and interleave 64-bit integers from the low half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpacklo_epi64 (__m128i a,  __m128i b)
PUNPCKLQDQ xmm, xmm/m128</p>
<h2 id="mm_unpacklo_epi8">mm_unpacklo_epi8</h2>
<p><code>mm_unpacklo_epi8</code></p>
<p>Unpack and interleave 8-bit integers from the low half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128i _mm_unpacklo_epi8 (__m128i a,  __m128i b)
PUNPCKLBW xmm, xmm/m128</p>
<h2 id="mm_unpacklo_pd">mm_unpacklo_pd</h2>
<p><code>mm_unpacklo_pd</code></p>
<p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_unpacklo_pd (__m128d a,  __m128d b)
UNPCKLPD xmm, xmm/m128</p>
<h2 id="mm_xor_pd">mm_xor_pd</h2>
<p><code>mm_xor_pd</code></p>
<p>Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in &quot;a&quot; and &quot;b&quot;, and store the results in &quot;dst&quot;.</p>
<p>__m128d _mm_xor_pd (__m128d a,  __m128d b)
XORPD xmm, xmm/m128</p>
<h2 id="mm_xor_si128">mm_xor_si128</h2>
<p><code>mm_xor_si128</code></p>
<p>Compute the bitwise XOR of 128 bits (representing integer data) in &quot;a&quot; and &quot;b&quot;, and store the result in &quot;dst&quot;.</p>
<p>__m128i _mm_xor_si128 (__m128i a,  __m128i b)
PXOR xmm, xmm/m128</p>

      </div>
  </div>
</div>
        </section>
        <footer>
          <hr>
          <p>Copyright &copy; 2023, Alexandre Mutel aka <a href="https://xoofx.com">xoofx</a> - Blog content licensed under the Creative Commons <a href="http://creativecommons.org/licenses/by/2.5/">CC BY 2.5</a> | Site generated by <a href="https://github.com/lunet-io/lunet">lunet</a> hosted on <a href="https://pages.github.com/">GitHub Pages</a></p>
        </footer>
      </div>
    </div>
  </body>
</html>